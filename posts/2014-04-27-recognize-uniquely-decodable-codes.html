<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Art Gallery Guardian">
    <meta name="author" content="Chao Xu">
    <meta name="google-site-verification" content="YE2oeW4OwVOPdVVfdpYIakOuD0A2Qo80W_sUbMJDGok" />
    <meta name="referrer" content="origin">
    <title>Recognize Uniquely Decodable Codes</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          var macros={
                  "\\C":"\\mathbb{C}",
                  "\\F":"\\mathbb{F}",
                  "\\e": "\\varepsilon",
                  "\\eps": "\\varepsilon",
                  "\\argmin": "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits",
                  "\\argmax": "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits",
                  "\\mex": "\\mathop{\\operatorname{mex}}",
                  "\\lcm": "\\mathop{\\operatorname{lcm}}",
                  "\\dist": "\\mathop{\\operatorname{dist}}",
                  "\\bigtriangleright": "{\\mathop{\\Large \\triangleright}}",
                  "\\bigtriangleleft": "{\\mathop{\\Large \\triangleleft}}",
                  '\\set':'\\left\\{ #1 \\right\\}',
                  '\\floor':'\\left\\lfloor #1 \\right\\rfloor',
                  '\\ceil':'\\left\\lceil #1 \\right\\rceil',
                  '\\abs':'\\left\\| #1 \\right\\|'
                  }
        var mathElements = document.getElementsByClassName("math");
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false, macros:macros} );
        }}});
    </script>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
  <link rel="stylesheet" href="/css/default.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/blog.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml" title="RSS"
      href="https://chaoxuprime.com/rss.xml">
  </head>
  <body>
    <header class="hide-on-print">
        <div id="site-title">
            <a href="/blog.html">The Art Gallery Guardian</a>
        </div>
    </header>
    <nav class="hide-on-print">
      <ul>
        <li><a href="/">About</a></li>
        <li><a href="/blog.html">Blog</a></li>
        <li><a href="/files/cv.pdf">CV</a></li>
        <li><a href="/tools.html">Tools</a></li>
      </ul>
    </nav>
    <main>
      <article>
        <h1 id="article-title">Recognize Uniquely Decodable Codes</h1>
        <br />
<div>
<p>A set of strings <span class="math inline">C</span> is called a uniquely decodable code, if <span class="math inline">C^*</span> has a unique factorization over <span class="math inline">C</span>. Namely, for each element <span class="math inline">s</span> in <span class="math inline">C^*</span>, there exist a unique finite sequence <span class="math inline">\{s_i\}_{i=1}^m</span> of elements in <span class="math inline">C</span>, such that <span class="math inline">s_1\ldots s_m = s</span>. We call the strings in <span class="math inline">C</span> a code string.</p>
<section class="theorem-environment Problem" id="Problem-1">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Uniquely Decodable Code Recognition</span></span>
<p>Let <span class="math inline">C</span> be a finite set of strings, decide if <span class="math inline">C</span> is a uniquely decodable code.</p>
</section>
<p>In general, the infinite version of the problem is undecidable. It is however decidable if <a href="http://cs.stackexchange.com/questions/6114/represent-string-as-concatenations"><span class="math inline">C</span> is a regular language</a>.</p>
<p>To solve this problem, we shall describe a formulation of <a href="http://en.wikipedia.org/wiki/Sardinas%E2%80%93Patterson_algorithm">Sardinas–Patterson algorithm</a>, which combines the description of <span class="citation" data-cites="jewelsofstringology">[<a href="#ref-jewelsofstringology">1</a>]</span> and <span class="citation" data-cites="rodeh">[<a href="#ref-rodeh">2</a>]</span>.</p>
<p>In the entire article, we assume the alphabet size is fixed.</p>
<p>For variable sized alphabet, let <span class="math inline">\sigma</span> be the number of distinct alphabet appeared in <span class="math inline">C</span>. There is an extra factor of <span class="math inline">\sigma</span> or <span class="math inline">\log \sigma</span> depending on if there exist a comparator for the alphabet.</p>
<p>Define <span class="math inline">S(C) = \{ v| xv = c, c\in C\}</span>, the set of suffixes of <span class="math inline">C</span>. <span class="math inline">I(C) = \{ v| c&#39;v = c, c&#39;\neq c, c&#39;,c\in C\}</span>, we call those initial suffix.</p>
<section class="theorem-environment Lemma" id="Lemma-2">
<span class="theorem-header"><span class="type">Lemma</span><span class="index">2</span></span>
<p><span class="math inline">C</span> is uniquely decodable if and only if there is no <span class="math inline">v\in I(C)</span>, such that <span class="math inline">vs\in C^*</span> and <span class="math inline">s\in C^*</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>If there exist such <span class="math inline">v</span> so <span class="math inline">vs,s\in C^*</span>. <span class="math inline">c&#39;v=c</span> for some <span class="math inline">c,c&#39;\in C</span>. Consider the string <span class="math inline">cs=c&#39;(vs)</span>. It has at least two factorization, one start with <span class="math inline">c</span>, the other start with <span class="math inline">c&#39;</span>, and <span class="math inline">c&#39;\neq c</span>.</p>
<p>Let no such <span class="math inline">v</span> exists. Consider some <span class="math inline">u\in C^*</span>. It can be written as <span class="math inline">cs</span> and <span class="math inline">c&#39;s&#39;</span> for <span class="math inline">c,c&#39;\in C</span>, <span class="math inline">s,s&#39;\in C^*</span>. Assume there is more than one factorization, then <span class="math inline">c&#39;\neq c</span> and wlog <span class="math inline">c&#39;v=c</span>. We arrive <span class="math inline">vs=s&#39;\in C^*</span>, a contradiction.</p>
</section>
<p>Consider a <span class="math inline">G=(V,A)</span> a directed graph. <span class="math inline">V=S(C)</span>. There is an arc from <span class="math inline">a</span> to <span class="math inline">b</span> iff <span class="math inline">ab=c</span> or <span class="math inline">cb=a</span> for some <span class="math inline">c\in C</span>.</p>
<section class="theorem-environment Theorem" id="Theorem-3">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p><span class="math inline">C</span> is uniquely decodable code iff there is no path from a vertex in <span class="math inline">I(C)</span> to <span class="math inline">\epsilon</span>.</p>
</section>
<section class="theorem-environment Proof" id="Proof-">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>For any arc <span class="math inline">uv</span>, if <span class="math inline">uv=c\in C</span>, then label the arc <span class="math inline">uv</span> by <span class="math inline">u</span>. Otherwise, label the arc with <span class="math inline">c</span> where <span class="math inline">cv = u</span>. It's then easy to see concatenate the labels on any walk from <span class="math inline">v</span> to <span class="math inline">\epsilon</span> spells a string of the form <span class="math inline">vs \in C^*</span> for <span class="math inline">s \in C^*</span>.</p>
<p>By induction, one can show that for a vertex <span class="math inline">v</span>, there exist string <span class="math inline">vs\in C^*</span>, where <span class="math inline">s\in C^*</span>, if and only if there is a path from <span class="math inline">v</span> to <span class="math inline">\epsilon</span>.</p>
</section>
<p>In order to compute the arcs on the graph, we need to answer two questions.</p>
<ol type="1">
<li>Is <span class="math inline">u</span> a prefix of <span class="math inline">c</span>? For all <span class="math inline">u\in S(C)</span> and <span class="math inline">c\in C</span>.</li>
<li>Is <span class="math inline">c</span> a prefix of <span class="math inline">u</span>? For all <span class="math inline">u\in S(C)</span> and <span class="math inline">c\in C</span>.</li>
</ol>
<p>Let <span class="math inline">k=|C|</span>, <span class="math inline">n=\sum_{c\in C}|c|</span>. It is known that we can build a generalized suffix tree for <span class="math inline">C</span> in linear time.</p>
<p>For the first question, &quot;Is <span class="math inline">u</span> a prefix of <span class="math inline">c</span>?&quot;, consider we constructed a suffix tree <span class="math inline">T</span> for <span class="math inline">C</span>. Transversing the suffix tree <span class="math inline">T(C)</span> with a code string <span class="math inline">c\in C</span>. Assume we have read a prefix <span class="math inline">u</span> of <span class="math inline">c</span>, we can check if <span class="math inline">u\in S(C)</span> in constant time during the transversal. If <span class="math inline">u\in S(C)</span>, then <span class="math inline">c=uv</span> where <span class="math inline">v\in S(C)</span>. It will add an arc <span class="math inline">uv</span>. We use <span class="math inline">O(|c|)</span> time to find all the arcs can be formed by answering the &quot;Is <span class="math inline">u</span> a prefix of <span class="math inline">c</span>&quot;. In total, we can answer question 1 in <span class="math inline">O(n)</span> time.</p>
<p>For the second question, we can also use the same suffix tree. Transverse the suffix tree with a code string <span class="math inline">c</span>. Find all the leaves in the subtree when the string <span class="math inline">c</span> ends. Those correspond to all strings <span class="math inline">u\in S(C)</span> such that <span class="math inline">c</span> is a prefix. Namely <span class="math inline">u=cv</span> where <span class="math inline">v\in S(C)</span>. The algorithm add an arc <span class="math inline">uv</span>. Note there might be many <span class="math inline">u</span> with this property, worst case <span class="math inline">O(n)</span>. This step might run in <span class="math inline">O(nk)</span> time.</p>
<p>It's not clear we can construct arcs between the vertices in constant time. The main difficulty lies in two suffix of two different code word might correspond to the same vertex in the graph. If we number the code words and name the suffixes by their length, then we can construct a <span class="math inline">O(n)</span> size table that maps each pair <span class="math inline">(i,j)</span>, which represents the suffix of length <span class="math inline">j</span> in the <span class="math inline">i</span>th string, to a vertex that represent the string. Simply build a trie for the reverse of the strings, and do some bookkeeping. This map allow us to add an edge in constant time.</p>
<p>The graph <span class="math inline">G</span> has at most <span class="math inline">O(nk)</span> arcs. We add a new vertex that has an arc to each initial vertices and apply a DFS from the new vertex. If it reaches the <span class="math inline">\epsilon</span> vertex, we return true, else we return false.</p>
<section class="theorem-environment Theorem" id="Theorem-4">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">4</span></span>
<p>There exist an algorithm to test if <span class="math inline">C</span> is a uniquely decodable code in <span class="math inline">O(nk)</span> time, where <span class="math inline">k=|C|</span> and <span class="math inline">n=\sum_{c\in C} |c|</span>.</p>
</section>
<p>I have an implementation in Haskell <a href="https://github.com/chaoxu/haskell-algorithm/blob/master/SardinasPatterson.hs">here</a>. Note it doesn't run in exactly <span class="math inline">O(nk)</span> time because of the <code>Map</code> takes <span class="math inline">O(\log n)</span> time. It can, however, be easily modified to run in <span class="math inline">O(nk)</span> time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-jewelsofstringology">
<p>[1] M. Crochemore, W. Rytter, <strong>Jewels of stringology</strong>, World Scientific, 2002.</p>
</div>
<div id="ref-rodeh">
<p>[2] M. Rodeh, <strong>A fast test for unique decipherability based on suffix trees (corresp.)</strong>, Information Theory, IEEE Transactions on. 28 (1982) 648–651 <a href="https://doi.org/10.1109/TIT.1982.1056535">10.1109/TIT.1982.1056535</a>.</p>
</div>
</div>

</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on 2014-04-27. </div>
    <div class="info">Tags: .</div>

</div>
      </article>
    </main>
    <footer class="hide-on-print">© 2010 - <time><script>document.write(new Date().getFullYear())</script></time> <a href="https://chaoxuprime.com">Chao Xu</a>. Licensed under <a href="http://www.wtfpl.net/txt/copying/">WTFPL v2</a> unless otherwise specified. <a href="/README.html">Blog README</a>.</footer>
    <!-- Fathom - simple website analytics - https://github.com/usefathom/fathom -->
    <script>
      (function(f, a, t, h, o, m){
        a[h]=a[h]||function(){
          (a[h].q=a[h].q||[]).push(arguments)
        };
        o=f.createElement('script'),
        m=f.getElementsByTagName('script')[0];
        o.async=1; o.src=t; o.id='fathom-script';
        m.parentNode.insertBefore(o,m)
      })(document, window, '//ec2-52-91-103-22.compute-1.amazonaws.com:8080/tracker.js', 'fathom');
      fathom('set', 'siteId', 'WXDOF');
      fathom('trackPageview');
    </script>
    <!-- / Fathom -->
  </body>
</html>
