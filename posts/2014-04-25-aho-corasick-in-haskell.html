<!DOCTYPE html><html lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Art Gallery Guardian">
    <meta name="author" content="Chao Xu">
    <meta name="google-site-verification" content="YE2oeW4OwVOPdVVfdpYIakOuD0A2Qo80W_sUbMJDGok">
    <meta property="og:title" content="The Aho–Corasick Automaton in Haskell">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="The Art Gallery Guardian">
    <meta property="article:tag" content="Algorithm, Haskell">
    <title>The Aho–Corasick Automaton in Haskell</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-4171915-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-4171915-2');
  </script>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/default.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/blog.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://chaoxuprime.com/rss.xml">
  </head>
  <body>
    <header class="hide-on-print">
        <div id="site-title">
            <a href="/blog.html">The Art Gallery Guardian</a>
        </div>
        <div style="display: none;">
          <img src="/files/chao/chao_thumb.jpg">
        </div>
    </header>
    <nav class="hide-on-print">
      <ul>
        <li><a href="/">About</a></li>
        <li><a href="/blog.html">Blog</a></li>
        <li><a href="/files/cv.pdf">CV</a></li>
        <li><a href="/tools.html">Tools</a></li>
      </ul>
    </nav>
    <main>
      <article>
        <h1 id="article-title">The Aho–Corasick Automaton in Haskell</h1>
        <br>
<div>
<p>It is common that one might want to match <span class="math inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span></span></span></span></span> different strings against one single text of length <span class="math inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>. One can of course apply the <a href="/posts/2014-04-11-the-kmp-algorithm-in-haskell.html">KMP algorithm</a> individually, and result an algorithm that runs in <span class="math inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(km)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.02778em;" class="mord mathdefault">O</span><span class="mopen">(</span><span style="margin-right: 0.03148em;" class="mord mathdefault">k</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span> time.</p>
<p>Faster algorithms are known. The idea is to build an finite state transducer that can output which strings is the suffix of the string it read. The Aho-Corasick automaton is a compressed version of such transducer, as the size does not depend on the size of the alphabet.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">import</span>           <span class="dt">Control.Arrow</span> (first)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span>           <span class="dt">Data.Function</span> (on)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span>           <span class="dt">Data.List</span>     (lookup, partition)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span>           <span class="dt">Data.Maybe</span>    (fromMaybe, <span class="dt">Maybe</span> (..))</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span>           <span class="dt">Data.Monoid</span>   (<span class="dt">All</span> (..), <span class="dt">Monoid</span>, getAll, mappend, mconcat,</span>
<span id="cb1-6"><a href="#cb1-6"></a>                                <span class="fu">mempty</span>)</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">data</span> <span class="dt">Automaton</span> a b <span class="ot">=</span> <span class="dt">Node</span> {<span class="ot">delta  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Automaton</span> a b,</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="ot">                           output ::</span> b</span>
<span id="cb1-9"><a href="#cb1-9"></a>                         }</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="ot">equivalentClasses ::</span> (a<span class="ot">-&gt;</span>a<span class="ot">-&gt;</span><span class="dt">Bool</span>)<span class="ot">-&gt;</span>[a]<span class="ot">-&gt;</span>[[a]]</span>
<span id="cb1-12"><a href="#cb1-12"></a>equivalentClasses eq <span class="ot">=</span> <span class="fu">foldl</span> parts []</span>
<span id="cb1-13"><a href="#cb1-13"></a>  <span class="kw">where</span> parts [] a <span class="ot">=</span> [[a]]</span>
<span id="cb1-14"><a href="#cb1-14"></a>        parts (x<span class="op">:</span>xs) a</span>
<span id="cb1-15"><a href="#cb1-15"></a>         <span class="op">|</span> eq (<span class="fu">head</span> x) a <span class="ot">=</span> (a<span class="op">:</span>x)<span class="op">:</span>xs</span>
<span id="cb1-16"><a href="#cb1-16"></a>         <span class="op">|</span> <span class="fu">otherwise</span>     <span class="ot">=</span> x<span class="op">:</span>parts xs a</span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="ot">buildAutomaton ::</span> (<span class="dt">Monoid</span> b,<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [([a],b)] <span class="ot">-&gt;</span> <span class="dt">Automaton</span> a b</span>
<span id="cb1-19"><a href="#cb1-19"></a>buildAutomaton xs <span class="ot">=</span> automaton</span>
<span id="cb1-20"><a href="#cb1-20"></a>  <span class="kw">where</span> automaton <span class="ot">=</span> build (<span class="fu">const</span> automaton) xs <span class="fu">mempty</span></span>
<span id="cb1-21"><a href="#cb1-21"></a></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="ot">build ::</span> (<span class="dt">Monoid</span> b,<span class="dt">Eq</span> a)<span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Automaton</span> a b) <span class="ot">-&gt;</span> [([a],b)] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Automaton</span> a b</span>
<span id="cb1-23"><a href="#cb1-23"></a>build trans xs out <span class="ot">=</span> node</span>
<span id="cb1-24"><a href="#cb1-24"></a>  <span class="kw">where</span> node  <span class="ot">=</span> <span class="dt">Node</span> (\x<span class="ot">-&gt;</span>fromMaybe (trans x) (<span class="fu">lookup</span> x table)) out</span>
<span id="cb1-25"><a href="#cb1-25"></a>        table <span class="ot">=</span>  <span class="fu">map</span> transPair <span class="op">$</span> equivalentClasses (on (<span class="op">==</span>) (<span class="fu">head</span> <span class="op">.</span> <span class="fu">fst</span>)) xs</span>
<span id="cb1-26"><a href="#cb1-26"></a>        transPair xs <span class="ot">=</span> (a, build (delta (trans a)) ys out)</span>
<span id="cb1-27"><a href="#cb1-27"></a>         <span class="kw">where</span> a  <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">fst</span> <span class="op">$</span> <span class="fu">head</span> xs</span>
<span id="cb1-28"><a href="#cb1-28"></a>               (ys,zs) <span class="ot">=</span> partition (<span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span> <span class="op">.</span> <span class="fu">fst</span>) <span class="op">$</span> <span class="fu">map</span> (first <span class="fu">tail</span>) xs</span>
<span id="cb1-29"><a href="#cb1-29"></a>               out <span class="ot">=</span> <span class="fu">mappend</span> (<span class="fu">mconcat</span> <span class="op">$</span> <span class="fu">map</span> <span class="fu">snd</span> zs) (output <span class="op">$</span> trans a)</span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="ot">match ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Automaton</span> a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb1-32"><a href="#cb1-32"></a>match a xs <span class="ot">=</span> <span class="fu">map</span> output <span class="op">$</span> <span class="fu">scanl</span> delta a xs</span>
<span id="cb1-33"><a href="#cb1-33"></a></span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="ot">match' ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[[a]]]</span>
<span id="cb1-35"><a href="#cb1-35"></a>match' pat <span class="ot">=</span> match (buildAutomaton <span class="op">$</span> <span class="fu">map</span> (\x<span class="ot">-&gt;</span> (x,[x])) pat)</span>
<span id="cb1-36"><a href="#cb1-36"></a></span>
<span id="cb1-37"><a href="#cb1-37"></a><span class="ot">isInfixOf' ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1-38"><a href="#cb1-38"></a>isInfixOf' xs ys <span class="ot">=</span> getAll <span class="op">$</span> <span class="fu">mconcat</span> <span class="op">$</span> match (buildAutomaton [(xs, <span class="dt">All</span> <span class="dt">True</span>)]) ys</span></code></pre></div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2014-04-25">2014-04-25</time>. </div>
    <div class="info">Tags: Algorithm, Haskell.</div>
</div>
      </article>
    </main>
    <footer class="hide-on-print">© 2010 - <time><script>document.write(new Date().getFullYear())</script></time> <a href="https://chaoxuprime.com" rel="author">Chao Xu</a>. Licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
    <a href="/README.html">Blog README</a>.</footer>
  

</body></html>
