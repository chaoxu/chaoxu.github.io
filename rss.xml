<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>The Art Gallery Guardian</title>
        <link>https://chaoxuprime.com</link>
        <description><![CDATA[Mostly notes on algorithms]]></description>
        <atom:link href="https://chaoxuprime.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 10 Apr 2020 00:00:00 UT</lastBuildDate>
        <item>
    <title>Maximize Cash Back</title>
    <link>https://chaoxuprime.com/posts/2020-04-10-maximize-cash-back.html</link>
    <description><![CDATA[<br />
<div>
<p>Credit cards often offers rewards for purchases. For example, a card that gives 5% cash back for grocery stores. Also, credit cards often can be used to buy gift cards for specific stores.</p>
<p>For example, one can use Chase Ink Cash (CIC) and go to Staples and buy gift card for Amazon for effectively 7.5% off Amazon.</p>
<p>However, there is usually a limit. CIC caps the reward spending to $2000. Still, it would translate to $1875 of savings. Anything afterwards only earns 1.5%.</p>
<p>I often do large purchases at some retailers, and I have huge number of credit cards. It make sense for me to optimize spending. I use historical data to estimate amount of spending at retailers, and come up with a nice optimization problem.</p>
<p>There are <span class="math inline">k</span> stores, we want to purchase an item of value <span class="math inline">d_i</span> in store <span class="math inline">i</span>, and want spend the least amount of money.</p>
<p>Stores can also sell gift cards for specific stores (some gives cash back), and one can use the gift card to buy item from other stores. For simplicity, we assume gift card for a particular store can be used to buy gift cards (so it work just like cash). <span class="math inline">g_{i,j}</span> is the cash back one obtain for buying <span class="math inline">1</span> unit of gift card for store <span class="math inline">j</span> from store <span class="math inline">i</span>.</p>
<p>We also have <span class="math inline">n</span> credit cards. Each credit card have an upper limit <span class="math inline">u_i</span>. For credit card <span class="math inline">i</span>, it gives cash back of <span class="math inline">c_{i,j}</span> per unit on store <span class="math inline">j</span> if total spend of the credit card is no larger than <span class="math inline">u_i</span>, otherwise it give cash back <span class="math inline">c&#39;_{i,j}</span>.</p>
<p>This is a min-cost flow problem. Indeed, let’s build the graph. Edges default to have infinite capacity and 0 cost. Node default to have 0 demand.</p>
<p>For credit card <span class="math inline">i</span>, we create <span class="math inline">3</span> nodes, <span class="math inline">a_i, b_i^+, b_i^-</span>. There is is edge <span class="math inline">(a_i,b_i^+)</span> with capacity <span class="math inline">u_i</span>, there is an edge <span class="math inline">(a_i,b_i^-)</span> with infinite capacity. For each store, we create a node <span class="math inline">s_i</span>, and there are edges <span class="math inline">(s_i,s_j)</span> with cost <span class="math inline">-g_{i,j}</span>. The demand on <span class="math inline">s_i</span> is <span class="math inline">d_i</span>. For each credit card <span class="math inline">i</span> and store <span class="math inline">j</span>, there is an edge <span class="math inline">(b_i^+,s_i)</span> with cost <span class="math inline">-c_{i,j}</span>, and an edge <span class="math inline">(b_i^-,s_i)</span> with cost <span class="math inline">-c&#39;_{i,j}</span>. Finally add a source node connect to each <span class="math inline">a_i</span>. Source node has demand <span class="math inline">-\sum_{i} d_i</span>.</p>
<p>Some stores does not allow gift card to be used to purchase more gift cards. Indeed, this was not the case a long time ago, until people abused the price difference to generate infinite money.</p>
<p>This can be fixed by duplicate this store into a cash version, so <span class="math inline">s_{c,i}</span> and gift card version <span class="math inline">s_{g,i}</span>. We redirect edges to the correct ones. Namely credit card goes to <span class="math inline">s_{c,i}</span> and edges from stores goes to <span class="math inline">s_{g,i}</span>. Also, create edges <span class="math inline">(s_{c,i},s_i)</span> and <span class="math inline">(s_{g,i},s_i)</span>.</p>
<p>We are only thinking about cash backs, but there could also be discounts. It is fairly rare to see discounts, especially for companies that sell other gift cards. The difference between cash back and discount is when you obtain your money back. Cash back you get your money back after the transaction. For discounts, you pay less.</p>
<p>Adding discounts <em>fundamentally</em> changes the problem. In the min-cost flow formulation, the cost keeps track of cash backs, and demand is keep track of how much money is spent. This does not work when there are discounts.</p>
<p>Instead, we have to venture into generalized flow. There is an extra factor of <span class="math inline">\gamma</span> on each edge, such that the flow going in is <span class="math inline">1</span>, then the flow going out is <span class="math inline">\gamma</span>.</p>
<p>Anyway, one thing I learned is using credit cards to buy gift cards from grocery store (Amex Gold) or staples (using Chase Ink Cash) are amazing. Netting you large discounts on many vendors you usually cannot get a huge discount for.</p>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2020-04-10">2020-04-10</time>. </div>
    <div class="info">Tags: math, life.</div>
</div>]]></description>
    <pubDate>Fri, 10 Apr 2020 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2020-04-10-maximize-cash-back.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Bounds on number of cuts</title>
    <link>https://chaoxuprime.com/posts/2019-11-27-bounds-on-cuts.html</link>
    <description><![CDATA[<br />
<div>
<p>Recently there are some advances on counting the number of min-cut in graphs.</p>
<p>Consider we have an undirected graph <span class="math inline">G=(V,E)</span> of <span class="math inline">n</span> vertices, and there are <em>positive</em> cost <span class="math inline">c:E\to \R^+</span> on the edges. We define <span class="math inline">c(F)=\sum_{e\in F}c(e)</span>, to be the cost (value) of <span class="math inline">F\subset E</span>.</p>
<p>Let <span class="math inline">\mathcal{P}</span> be a partition of <span class="math inline">V</span> where each partition class is non-empty. We define <span class="math inline">E(\mathcal{P})</span> to be the set of edges with end points in two different partition classes. A set of edges <span class="math inline">F</span> is called a <em><span class="math inline">k</span>-cut</em>, if <span class="math inline">F=E(\mathcal{P})</span> for some <span class="math inline">\mathcal{P}</span> such that <span class="math inline">|\mathcal{P}|\geq k</span>.</p>
<p>We stress that by this definition, a <span class="math inline">k</span>-cut is a <span class="math inline">k-1</span>-cut. A <em>cut</em> is a <span class="math inline">2</span>-cut. A min-<span class="math inline">k</span>-cut is a <span class="math inline">k</span>-cut of minimum value (cost). We let <span class="math inline">\lambda_k</span> to denote the value of the min-<span class="math inline">k</span>-cut.</p>
<p>It is well known that the number of min-cuts in a graph is <span class="math inline">{n\choose 2} = O(n^2)</span>. <span class="citation" data-cites="KargerS96">[<a href="#ref-KargerS96" role="doc-biblioref">1</a>]</span></p>
<p>In the entire article, unless specifically stated, we assume <span class="math inline">k</span> is a fixed integer at least <span class="math inline">2</span>, and <span class="math inline">\alpha</span> is a fixed value at least <span class="math inline">1</span>.</p>
<p>We can express the state alternatively.</p>
<div class="theorem-environment Theorem" data-index="1" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)\leq \lambda_2</span> is <span class="math inline">O(n^2)</span>.</p>
</div>
<h1 id="bounds-related-to-scaling-of-the-min-cut"><span class="header-section-number">1</span> Bounds related to scaling of the min-cut</h1>
<p>What happens when we want to know about the number of cuts with value at most <span class="math inline">\alpha \lambda_2</span>?</p>
<p>By simply analyzing Karger’s algorithm, one can obtain the following.</p>
<div class="theorem-environment Theorem" data-index="2" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)\leq \alpha \lambda_2</span> is <span class="math inline">O(n^{2\alpha})</span>.</p>
</div>
<p>With more careful analysis using tree packing, Karger obtained the following <span class="citation" data-cites="Karger00">[<a href="#ref-Karger00" role="doc-biblioref">2</a>]</span>.</p>
<div class="theorem-environment Theorem" data-index="3" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)\leq \alpha \lambda_2</span> is <span class="math inline">O(n^{\floor{2\alpha}})</span>.</p>
</div>
<p>Indeed, we do have a lower bound of <span class="math inline">{n \choose \floor{2\alpha}}</span>. Just consider an unweighted cycle, where min-cut has value <span class="math inline">2</span>. We can pick any <span class="math inline">\floor{2\alpha}</span> edges, which forms a cut of value at most <span class="math inline">\alpha</span> times the min-cut.</p>
<p>Note that we require <span class="math inline">\alpha</span> to a fixed value. This is because there is a dependency on <span class="math inline">\alpha</span> hidden inside the big <span class="math inline">O</span>. Our lower bound is absolute and does not depending on <span class="math inline">\alpha</span> being fixed. It be interesting to obtain a matching upper bound. Hence we can consider the problem with strict inequality.</p>
<div id="approxcutconjecture" class="theorem-environment Conjecture" data-index="4" type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span class="index">4</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)&lt; \alpha \lambda_2</span> is <span class="math inline">O(n^{\ceil{2\alpha}-1})</span>.</p>
</div>
<p>Henzinger and Williamson showed the conjecture true for all <span class="math inline">\alpha\leq \frac{3}{2}</span> <span class="citation" data-cites="HenzingerW96">[<a href="#ref-HenzingerW96" role="doc-biblioref">3</a>]</span>.</p>
<h1 id="bounds-related-to-min-k-cut"><span class="header-section-number">2</span> Bounds related to min-<span class="math inline">k</span>-cut</h1>
<p>There are multiple ways to obtain the following theorem. For example, directly generalize Karger’s argument for cut counting.</p>
<div class="theorem-environment Theorem" data-index="5" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">5</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)\leq \lambda_k</span> is <span class="math inline">O(n^{2(k-1)})</span>.</p>
</div>
<p>There were many attempts, and people can only obtain lower bounds of the form <span class="math inline">{n\choose k}</span>. Again, a cycle would be an example of such lower bound. The min-<span class="math inline">k</span>-cut has value <span class="math inline">k</span>, and can be obtained by picking any <span class="math inline">k</span> edges. The gap is pretty large. Hence one would tempt to conjecture the following.</p>
<div id="kcutconjecture" class="theorem-environment Conjecture" data-index="6" type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span class="index">6</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)\leq \lambda_k</span> is <span class="math inline">O(n^k)</span>.</p>
</div>
<p>Recently, Gupta, Lee and Li almost closes the gap <span class="citation" data-cites="GuptaLL19">[<a href="#ref-GuptaLL19" role="doc-biblioref">4</a>]</span>.</p>
<div class="theorem-environment Theorem" data-index="7" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">7</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)\leq \lambda_k</span> is <span class="math inline">\hat{O}(n^k)</span>.</p>
</div>
<p>Here <span class="math inline">\hat{O}</span> hides a factor smaller than any <span class="math inline">n^\epsilon</span>. While closing the gap, they showed thhe following interesting theorem.</p>
<div class="theorem-environment Theorem" data-index="8" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">8</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)\leq \frac{(2-\epsilon)\lambda_k}{k}</span> is <span class="math inline">O(n)</span>.</p>
</div>
<div class="theorem-environment Conjecture" data-index="9" type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span class="index">9</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)&lt; \frac{2\lambda_k}{k}</span> is <span class="math inline">O(n)</span>.</p>
</div>
<p>Note this theorem is basically shows we can also obtain interesting results for <span class="math inline">\alpha = \frac{2-\epsilon}{k} &lt; 1</span>.</p>
<p>How about approximate min-<span class="math inline">k</span>-cuts? Chekuri, Quanrud and I extended the tree packing analysis of Karger, and obtained the following result for <span class="math inline">k</span>-cuts <span class="citation" data-cites="ChekuriQX19">[<a href="#ref-ChekuriQX19" role="doc-biblioref">5</a>]</span>.</p>
<div class="theorem-environment Theorem" data-index="10" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">10</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)\leq \alpha \lambda_k</span> is <span class="math inline">O(n^{\floor{\alpha 2(k-1)}})</span>.</p>
</div>
<p>Combining the <a href="#kcutconjecture" title="Conjecture 6">Conjecture 6</a> and <a href="#approxcutconjecture" title="Conjecture 4">Conjecture 4</a>, we get a unified conjecture, even for <span class="math inline">\alpha&lt;1</span>.</p>
<div class="theorem-environment Conjecture" data-index="11" type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span class="index">11</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c(F)&lt; \alpha \lambda_k</span> is <span class="math inline">O(n^{\ceil{\alpha k}-1})</span>.</p>
</div>
<h1 id="bounds-on-parametric-cuts"><span class="header-section-number">3</span> Bounds on parametric cuts</h1>
<p>Now, let’s consider parametric cuts. Consider we have <span class="math inline">d</span> weight functions <span class="math inline">c_1,\ldots,c_d:E\to \R_{\geq 0}</span>. Define <span class="math inline">c_\mu(e) = \sum_{i=1}^d \mu_i c_i(e)</span>. We interested in knowing about cuts <span class="math inline">F</span> such that <span class="math inline">c_\mu(F)</span> is bounded by <span class="math inline">\alpha \lambda_{\mu,k}</span>, where <span class="math inline">\lambda_{\mu,k}</span> is the min-<span class="math inline">k</span>-cut value when the cost function is <span class="math inline">c_\mu</span>.</p>
<p>Karger showed the following <span class="citation" data-cites="Karger16">[<a href="#ref-Karger16" role="doc-biblioref">6</a>]</span>.</p>
<div class="theorem-environment Theorem" data-index="12" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">12</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c_\mu(F)\leq \lambda_{\mu,2}</span> for some <span class="math inline">\mu\in \R_{\geq 0}^d</span> is <span class="math inline">O(n^{d+1})</span>.</p>
</div>
<p>A even more general theorem follows.</p>
<div class="theorem-environment Theorem" data-index="13" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">13</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c_\mu(F)\leq \alpha \lambda_{\mu,k}</span> for some <span class="math inline">\mu\in \R_{\geq 0}^d</span> is <span class="math inline">O(n^{2\alpha(k-1)+d-1})</span>.</p>
</div>
<p>Hence, we would have the following conjecture.</p>
<div class="theorem-environment Conjecture" data-index="14" type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span class="index">14</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c_\mu(F)&lt; \alpha \lambda_{\mu,k}</span> for some <span class="math inline">\mu\in \R_{\geq 0}^d</span> is <span class="math inline">O(n^{\ceil{\alpha k}+d-2})</span>.</p>
</div>
<p>Note, we might relax the requirement that all <span class="math inline">c_i</span> and <span class="math inline">\mu</span> are non-negative. Aissi et. al. showed the following <span class="citation" data-cites="AissiMMQ15">[<a href="#ref-AissiMMQ15" role="doc-biblioref">7</a>]</span>.</p>
<div class="theorem-environment Theorem" data-index="15" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">15</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c_\mu(F)\leq \lambda_{\mu}</span> for some <span class="math inline">c_\mu\geq 0</span> is <span class="math inline">O(m^d n^2\log^{d-1} n)</span>.</p>
</div>
<p>The following would be even stronger conjecture.</p>
<div class="theorem-environment Conjecture" data-index="16" type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span class="index">16</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span class="math inline">c_\mu(F) &lt; \alpha \lambda_{\mu,k}</span> for some <span class="math inline">c_\mu\geq 0</span> is <span class="math inline">O(n^{\ceil{\alpha k}+d-2})</span>.</p>
</div>
<h1 id="projected-cut-bounds"><span class="header-section-number">4</span> Projected cut bounds</h1>
<p>Let <span class="math inline">\tau_e = \min_{U:e\in \delta(U)}c(\delta(U))</span>. Fung et. al. showed a projected generalization of the cut counting bound <span class="citation" data-cites="FungHHP19">[<a href="#ref-FungHHP19" role="doc-biblioref">8</a>]</span>. Let <span class="math inline">E_\lambda = \set{ e | \tau_e \geq x }</span>.</p>
<div class="theorem-environment Theorem" data-index="17" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">17</span></span>
<p>The number of sets of the form <span class="math inline">F\cap E_\lambda</span> where <span class="math inline">F</span> is a cut such that <span class="math inline">c(F)\leq \alpha \lambda</span> is <span class="math inline">O(n^{2\alpha})</span>.</p>
</div>
<p>If we let <span class="math inline">\lambda</span> be the min-cut value, this is precisely the approximate cut counting bound.</p>
<p>We can of course ask if all our theorem can be applied to projected cuts. We don’t even know if it extends to <span class="math inline">k</span>-cuts. However, we can expect the following ultimate conjecture.</p>
<p>Let <span class="math inline">\tau_{\mu,k,e}</span> be the minimum over all <span class="math inline">c_{\mu}(F)</span>, where <span class="math inline">F</span> is a <span class="math inline">k</span>-cut containing <span class="math inline">e</span>. Let <span class="math inline">E_{\mu,k,\lambda} = \set{e | \tau_{\mu,k,e} \geq \lambda}</span>.</p>
<div class="theorem-environment Conjecture" data-index="18" type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span class="index">18</span></span>
<p>The number of sets of the form <span class="math inline">F\cap E_{\mu,k,\lambda}</span> where <span class="math inline">F</span> is a cut such that <span class="math inline">c_{\mu}(F)&lt; \alpha \lambda</span> for some <span class="math inline">c_\mu\geq 0</span> is <span class="math inline">O(n^{\ceil{\alpha k}+d-2})</span>.</p>
</div>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-KargerS96">
<p>[1] D. Karger, C. Stein, <strong>A new approach to the minimum cut problem</strong>, Journal of ACM. 43 (1996) 601–640.</p>
</div>
<div id="ref-Karger00">
<p>[2] D.R. Karger, <strong>Minimum cuts in near-linear time</strong>, J. ACM. 47 (2000) 46–76 <a href="https://doi.org/10.1145/331605.331608">10.1145/331605.331608</a>.</p>
</div>
<div id="ref-HenzingerW96">
<p>[3] M. Henzinger, D.P. Williamson, <strong>On the number of small cuts in a graph</strong>, Information Processing Letters. 59 (1996) 41–44 <a href="https://doi.org/https://doi.org/10.1016/0020-0190(96)00079-8">https://doi.org/10.1016/0020-0190(96)00079-8</a>.</p>
</div>
<div id="ref-GuptaLL19">
<p>[4] A. Gupta, E. Lee, J. Li, <strong>The Karger-Stein Algorithm is Optimal for <span class="math inline">k</span>-cut</strong>, arXiv E-Prints. (2019) arXiv:1911.09165.</p>
</div>
<div id="ref-ChekuriQX19">
<p>[5] C. Chekuri, K. Quanrud, C. Xu, LP Relaxation and Tree Packing for Minimum k-cuts, in: J.T. Fineman, M. Mitzenmacher (Eds.), 2nd Symposium on Simplicity in Algorithms (<strong>Sosa</strong> 2019), Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany, 2018: pp. 7:1–7:18 <a href="https://doi.org/10.4230/OASIcs.SOSA.2019.7">10.4230/OASIcs.SOSA.2019.7</a>.</p>
</div>
<div id="ref-Karger16">
<p>[6] D.R. Karger, Enumerating parametric global minimum cuts by random interleaving, in: Proceedings of the Forty-Eighth Annual Acm Symposium on Theory of Computing, ACM, New York, NY, USA, 2016: pp. 542–555 <a href="https://doi.org/10.1145/2897518.2897578">10.1145/2897518.2897578</a>.</p>
</div>
<div id="ref-AissiMMQ15">
<p>[7] H. Aissi, A.R. Mahjoub, S.T. McCormick, M. Queyranne, <strong>Strongly polynomial bounds for multiobjective and parametric global minimum cuts in graphs and hypergraphs</strong>, Mathematical Programming. 154 (2015) 3–28 <a href="https://doi.org/10.1007/s10107-015-0944-8">10.1007/s10107-015-0944-8</a>.</p>
</div>
<div id="ref-FungHHP19">
<p>[8] W.-S. Fung, R. Hariharan, N.J.A. Harvey, D. Panigrahi, <strong>A general framework for graph sparsification</strong>, SIAM Journal on Computing. 48 (2019) 1196–1223 <a href="https://doi.org/10.1137/16M1091666">10.1137/16M1091666</a>.</p>
</div>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-11-27">2019-11-27</time>. </div>
    <div class="info">Tags: Graph Theory.</div>
</div>]]></description>
    <pubDate>Wed, 27 Nov 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-11-27-bounds-on-cuts.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Word break with cost</title>
    <link>https://chaoxuprime.com/posts/2019-09-19-word-break-with-cost.html</link>
    <description><![CDATA[<br />
<div>
<div class="theorem-environment Problem" data-index="1" type="Problem">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a set of strings <span class="math inline">W</span>, a cost function <span class="math inline">c:W\to \R</span> and a string <span class="math inline">s</span>. Find elements <span class="math inline">w_1,\ldots,w_k\in W</span> such that <span class="math inline">s=w_1\ldots w_k</span>, and <span class="math inline">\sum_{i=1}^k c(w_i)</span> is minimized.</p>
</div>
<p>This problem is a generalization of the <a href="https://leetcode.com/problems/word-break/">word break</a> problem on leetcode. Many algorithms you see online assumes that string in <span class="math inline">W</span> has constant length, checking the hash table takes <span class="math inline">O(1)</span> time, and obtain an <span class="math inline">O(n^2)</span> time algorithm. It is not as easy. Here we show an algorithm that considers the strings in <span class="math inline">W</span> have arbitrary length.</p>
<p>Consider the following graph <span class="math inline">G=(V,E)</span>, where <span class="math inline">V=\set{0,\ldots,n}</span>, and there is an edge from <span class="math inline">i</span> and <span class="math inline">j</span>, if <span class="math inline">s[i+1..j]=w\in W</span>, and the label of the edge <span class="math inline">(i,j)</span> is the string <span class="math inline">w</span>, and the cost is <span class="math inline">c(w)</span>. Let <span class="math inline">z</span> be number of substrings in <span class="math inline">s</span> matches some element in <span class="math inline">W</span>. The graph has <span class="math inline">z</span> edges. Note <span class="math inline">z=O(n\sqrt{L})</span>. Indeed, the sum of the length of the labels of all outgoing edges cannot be more than <span class="math inline">L</span>, and the length of each label is different. Hence each vertex can have at most <span class="math inline">O(\sqrt{L})</span> outgoing edges. The graph is a DAG, so we can find the shortest path from <span class="math inline">0</span> to <span class="math inline">n</span> in linear time with respect to the number of edges. This shows if we can compute the graph in <span class="math inline">O(z+L)</span> time, then we solve the problem in <span class="math inline">O(z+L)</span> time.</p>
<p>We can build the Aho–Corasick automaton for <span class="math inline">W</span> in <span class="math inline">O(L)</span> time. It can be used to find all substrings of <span class="math inline">s</span> that matches something in <span class="math inline">W</span> by traversing the automaton once. The running time is the total number of substrings matched, which is <span class="math inline">O(z)</span>. Hence building the graph takes <span class="math inline">O(z+L)</span> time. <span class="math inline">z</span> is clearly no more than <span class="math inline">nm</span>, where <span class="math inline">m=|W|</span>. Also, it is also clear <span class="math inline">z=O(n\sqrt{L})</span>. Indeed, there can be at most <span class="math inline">O(\sqrt{L})</span> edges start from <span class="math inline">i</span>, since each edge has a label of different length, and sum of those length labels is no larger than <span class="math inline">L</span>.</p>
<p>If we only want to know if there exists a solution, then there is a <span class="math inline">\tilde{O}(nL^{1/3}+L)</span> time algorithm <span class="citation" data-cites="BringmannGL17">[<a href="#ref-BringmannGL17" role="doc-biblioref">1</a>]</span>. The algorithm is close to optimal assuming the algorithm is combinatorial and the alphabet can be arbitrarily large.</p>
<p>Can we obtain similar running time for the word break with cost problem? There are evidence against it. If the alphabet is unary, this problem is equivalent to the unbounded knapsack problem, which likely does not have an algorithm with running time <span class="math inline">O((n+L)^{2-\e})</span> for any <span class="math inline">\e&gt;0</span> <span class="citation" data-cites="CyganMWW19">[<a href="#ref-CyganMWW19" role="doc-biblioref">2</a>]</span> and <span class="math inline">m</span> can be as large as <span class="math inline">\Omega(\sqrt{L})</span>. Of course, this does not mean there might not be a <span class="math inline">O(nL^{1/3}+L)</span> time algorithm, since the reduction involved in the paper might not hold when we require <span class="math inline">m=\Omega(\sqrt{L})</span>.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-BringmannGL17">
<p>[1] K. Bringmann, A. Grønlund, K.G. Larsen, A dichotomy for regular expression membership testing, in: 2017 Ieee 58th Annual Symposium on Foundations of Computer Science (Focs), 2017: pp. 307–318 <a href="https://doi.org/10.1109/FOCS.2017.36">10.1109/FOCS.2017.36</a>.</p>
</div>
<div id="ref-CyganMWW19">
<p>[2] M. Cygan, M. Mucha, K. Węgrzycki, M. W, <strong>On problems equivalent to (min,+)-convolution</strong>, ACM Trans. Algorithms. 15 (2019) 14:1–14:25 <a href="https://doi.org/10.1145/3293465">10.1145/3293465</a>.</p>
</div>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-09-19">2019-09-19</time>. </div>
    <div class="info">Tags: Algorithm.</div>
</div>]]></description>
    <pubDate>Thu, 19 Sep 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-09-19-word-break-with-cost.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Traditional vs Roth IRA under fixed amount of investment</title>
    <link>https://chaoxuprime.com/posts/2019-09-06-traditional-ira-vs-roth-ira.html</link>
    <description><![CDATA[<br />
<div>
<p>I’ve read a lot of articles on Traditional vs Roth IRA. One can do a serious mathematical analysis of which one is better, given that you want to invest a total of <span class="math inline">x</span> income into the account for a particular year. Money in excess of <span class="math inline">x</span> will be put in a normal investment account.</p>
<p>There is a widely held belief that if your effective tax rate is higher today than when you cash out, it is always better to do pre-tax contribution (Traditional IRA). However, we can show this is not always the case. You need effective tax rate to be somewhat lower unless you are in the lowest of tax bracket. Assume for simplicity, you don’t have to pay state income tax.</p>
<p>Assumption you way more than enough money to maximize the contribution.</p>
<p>Here are the 3 options.</p>
<ul>
<li>Type 1: (Traditional IRA, 401(k)) No tax when contributing, taxed as ordinary income afterwards.</li>
<li>Type 2: (Roth IRA, Roth 401(k)) Taxed when contributing, and no taxes with withdrawal.</li>
<li>Type 3: Normal account, taxed when contributing, and tax with either ordinary income or capital gain taxes depending on type.</li>
</ul>
<p>Consider the simplest model. You have a stock that you buy and hold. It generates no dividends. At the time when you sell it, it worths <span class="math inline">k</span> times more. All your money will be going into that stock.</p>
<p>Assume you allocate <span class="math inline">x</span> income into <span class="math inline">x_1,x_2,x_3</span>, which is the amount of income allocated into Type <span class="math inline">1,2,3</span> accounts, respectively.</p>
<p>How much after tax income is generated when you sell the stock?</p>
<p>Let <span class="math inline">\alpha</span> be the (approximate) effective tax rate today, <span class="math inline">\alpha&#39;</span> is an (approximate) effective tax rate when you sell. <span class="math inline">\beta&#39;</span> is the capital gain tax rate.</p>
<p>The after-tax income contributed by each account is</p>
<ul>
<li>Type 1: <span class="math inline">kx_1(1-\alpha&#39;)</span></li>
<li>Type 2: <span class="math inline">kx_2(1-\alpha)</span></li>
<li>Type 3: <span class="math inline">(k-1)x_3(1-\alpha)(1-\beta&#39;) + x_3(1-\alpha) = x_3(1-\alpha)((k-1)(1-\beta&#39;)+1)</span></li>
</ul>
<p>Now, we also have the following constraint. <span class="math inline">x_1+x_2(1-\alpha)=B</span>, where <span class="math inline">B</span> is the maximum contribution into type 1 and type 2 accounts. This happens because they share the same bound (this is true for both 401(k) and IRA). Note that <span class="math inline">x_1+x_2+x_3=x</span>. Since <span class="math inline">B</span> and <span class="math inline">x</span> are fixed, we have <span class="math inline">x_2 = \frac{B-x_1}{1-\alpha}</span>, and <span class="math inline">x_3 = x-x_1-\frac{B-x_1}{1-\alpha}</span></p>
<p>Define <span class="math inline">f(x_1)=kx_1(1-\alpha&#39;) + k(B-x_1) + (x-x_1-\frac{B-x_1}{1-\alpha})(1-\alpha)((k-1)(1-\beta&#39;)+1)</span>, which is a linear function. We take the derivative of <span class="math inline">f</span> and obtain the slope if <span class="math inline">k(\alpha-\alpha&#39;)- (k-1)\alpha\beta&#39;</span>. If the slope is positive, it means when should maximize type <span class="math inline">1</span> account, and if the slope is negative, we should maximize type <span class="math inline">2</span> account.</p>
<p>In order for the inequality to work for all <span class="math inline">k&gt;1</span>, we need <span class="math inline">\alpha-\alpha&#39;\geq \alpha\beta&#39;</span>. In other words, we need <span class="math inline">\alpha&#39;\leq \alpha(1-\beta&#39;)</span> in order to safely say it is better to maximize type 1.</p>
<p>We didn’t even consider what happens if there are dividend involved. It would shift the scale even more toward type 2.</p>
<p>I think the moral of the story is you have to be careful and actually model everything correctly. Also, since there is no way to know the tax rate in the future, some people hedge the risk by putting money in both type 1 and type 2 accounts.</p>
<p>It looks like this still suggest putting money in Traditional IRA is better than Roth IRA if your current tax rate is <em>much higher</em> than your future tax rate.</p>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-09-06">2019-09-06</time>. </div>
    <div class="info">Tags: Tax.</div>
</div>]]></description>
    <pubDate>Fri, 06 Sep 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-09-06-traditional-ira-vs-roth-ira.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Impossibility theorem of marriage tax</title>
    <link>https://chaoxuprime.com/posts/2019-08-28-impossibility-theorm-marriage-tax.html</link>
    <description><![CDATA[<br />
<div>
<p>It is well known that there could be <a href="https://en.wikipedia.org/wiki/Marriage_penalty">marriage penalty or marriage bonus</a>. For example, in 2019, if two people each make more than $306,175, then they have to pay more tax after getting married. In the worst case, they have to pay $8,165 more. Not that bad. However, if one person make all the money, and the other has no income, then together they will always pay a smaller amount of tax.</p>
<p>I always thought this is because the tax code is designed to advocate sole breadwinner in a family, and the other person is stay at home husband/wife. Recently, I realized it is just mathematically impossible to have anything other than a linear tax and preserve some other nice properties.</p>
<p>Indeed, this was shown by Lovell <span class="citation" data-cites="Lovell82">[<a href="#ref-Lovell82" role="doc-biblioref">1</a>]</span>.</p>
<p>Let <span class="math inline">\R_+</span> be the positive reals. Consider functions <span class="math inline">S:\R_+ \to \R_+</span> and <span class="math inline">J:\R_+ \to\R_+</span>. The first is for tax paid for a single person and tax paid for a married couple file jointly. The input for married file jointly is a single number, which is the combination of the taxable income of the couple. This is called horizontal equity in marriage.</p>
<p>Marriage neutral is precisely when <span class="math inline">S(x)+S(y) = J(x+y)</span>. We define a few notions, it is not completely the same as the ones in Lovell’s paper <span class="citation" data-cites="Lovell82">[<a href="#ref-Lovell82" role="doc-biblioref">1</a>]</span>, but it essentially demonstrate the same idea.</p>
<p>A tax function <span class="math inline">T</span> should have the following properties.</p>
<ol type="1">
<li>Reasonable Tax: <span class="math inline">0\leq T(x)\leq x</span>. Indeed, one should not tax people more than their income. The taxation system does not want to give free money to low income people either.</li>
<li>Principal of Progressiveness: there is some <span class="math inline">c&gt;0</span> such that <span class="math inline">\frac{T(x)}{x} &gt; \frac{T(y)}{y}</span> for all <span class="math inline">x&gt;y&gt;c</span>. Basically, the rich should pay a larger proportion of their money to taxes.</li>
</ol>
<p>For a marriage neutral system, the reasonable tax requirement would prove that <span class="math inline">S(x) = ax</span> for <span class="math inline">a\in[0,1]</span>. It is easy to see we cannot hope to have principal of progressiveness.</p>
<div class="theorem-environment Remark" type="Remark">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>Married filing separately is always no better than them being single and file their own taxes.</p>
</div>
<p>I personally think there should not be a marriage penalty at any income level to encourage marriage. Of course, people might disagree and think the rich should have a marriage penalty, since it is a small amount compare to their total income so they won’t care anyways.</p>
<p>Anyway, consider the world where there can only be marriage bonus. That is we have the property <span class="math inline">S(x)+S(y)\geq J(x+y)</span>. An <em>easy tax function</em> is a function that has reasonable tax property, and is a piecewise-linear convex that has at least <span class="math inline">1</span> breakpoint larger than <span class="math inline">0</span>. This is strictly stronger than principal of progressiveness. This is satisfied by the current personal income tax function used by the IRS.</p>
<p>Let <span class="math inline">S</span> be a easy tax function, then we can obtain an easy tax function <span class="math inline">J</span> that always gives a marriage bonus. Indeed, let <span class="math inline">J = \inf_{a+b=x,a,b\geq 0} S(a)+S(b)</span>. <span class="math inline">J</span> is extreme in a way that any function greater than it at any point will cause marriage penalty. <span class="math inline">J</span> is the infimal convolution of <span class="math inline">S</span> and itself, which would also be piecewise-linear convex. If <span class="math inline">S</span> is the personal income tax function for 2019, then <span class="math inline">J</span> matches the 2019 IRS married file jointly function up to $612,350! For some reason I do not know, the IRS decide to cut this <span class="math inline">J</span> off at $612,350, and then impose a higher rate just to penalize families with two very high income earners.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-Lovell82">
<p>[1] M.C. LOVELL, <strong>ON taxing marriages</strong>, National Tax Journal. 35 (1982) 507–510.</p>
</div>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-08-28">2019-08-28</time>. </div>
    <div class="info">Tags: Tax.</div>
</div>]]></description>
    <pubDate>Wed, 28 Aug 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-08-28-impossibility-theorm-marriage-tax.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Long distance couple back-to-back ticketing</title>
    <link>https://chaoxuprime.com/posts/2019-06-18-long-distance-couple-back-to-back-ticketing.html</link>
    <description><![CDATA[<br />
<div>
<p>The reason I explored <a href="https://chaoxuprime.com/posts/2019-06-15-covert-back-to-back-ticketing.html">an algorithm for covert back-to-back ticketing</a> in the previous blog post, was because as someone currently in a long distance relationship. It is important to save money on travel.</p>
<p>For long distance couples, two people can fly. Consider if the couple decides be together each weekend, one can fly to the city of the other on Friday night, and comes back on Sunday night. Again we can take advantage of the back-to-back ticketing.</p>
<p>Let <span class="math inline">M</span> be a matching of a graph <span class="math inline">G</span> where the edges are two colored. <span class="math inline">M</span> is called <em>valid</em> if vertex <span class="math inline">2i</span> and <span class="math inline">2i-1</span> are contained in the same colored edge in <span class="math inline">M</span>.</p>
<div class="theorem-environment Problem" data-index="1" type="Problem" title="Couple back-to-back ticketing problem">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Couple back-to-back ticketing problem</span></span>
<p><strong>Input:</strong> A multigraph <span class="math inline">G=(V,E)</span> where <span class="math inline">V\subseteq [n]</span>, where each edge can be either red or blue, and there is an edge cost function <span class="math inline">c:E\to \R^+</span>.</p>
<p><strong>Output:</strong> A valid perfect matching <span class="math inline">M</span> (allowing self-loops), such that the cost is minimized.</p>
</div>
<p>Unfortunately, I don’t see how to solve this problem in polynomial time. I could convert this problem to something that might be solved in polynomial time in the future.</p>
<p>Note we can split the vertices. That is, for vertex <span class="math inline">i</span>, we split it into <span class="math inline">(i,R)</span> and <span class="math inline">(i,B)</span> for its blue and red counter part. A matching is <em>paired</em> if <span class="math inline">(2i,C)</span> and <span class="math inline">(2i-1,C)</span> both has to be matched, where <span class="math inline">C\in \set{R,B}</span>. The matching is <em>split</em> if <span class="math inline">(i,R)</span> and <span class="math inline">(i,B)</span> cannot be both in the matching.</p>
<p>If we just enforce one property – paired or split – then it is solvable in polynomial time. Indeed, both are matching under restrictions. We are interested in finding a matching <span class="math inline">M</span>, such that the vertices covered by <span class="math inline">M</span> is in some special structure. Namely <span class="math inline">\Delta</span>-matroid. Since the paired property is a very special <span class="math inline">\Delta</span>-matroid <span class="citation" data-cites="KakimuraT14">[<a href="#ref-KakimuraT14" role="doc-biblioref">1</a>]</span>, which was first solved in <span class="citation" data-cites="HefnerK95">[<a href="#ref-HefnerK95" role="doc-biblioref">2</a>]</span>. The second property is partition matroid, which can be handled by <a href="/posts/2019-04-27-maximum-weight-hierarchical-b-matching.html">hierarchical <span class="math inline">b</span>-matching</a>. Reader can see each individual restriction, the problem can be turned into a maximum weight perfect matching.</p>
<p>If we enforce both property, the problem is open. Although the structure is still very special, it is an <a href="https://en.wikipedia.org/wiki/Delta-matroid">even <span class="math inline">\Delta</span>-matroid</a>. <a href="http://www.math.keio.ac.jp/~kakimura/">Naonori Kakimura</a> communicated a more fundamental problem which can be solved by this problem.</p>
<div class="theorem-environment Problem" data-index="2" type="Problem" title="Matching with disjoint pair constraints">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span><span class="name">Matching with disjoint pair constraints</span></span>
<p>Given a graph where the edges are partitioned into pairs. Find a maximum matching where it uses at most one edge of each pair.</p>
</div>
<p>I would be very interested to know the solution to that problem.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-KakimuraT14">
<p>[1] N. Kakimura, M. Takamatsu, <strong>Matching Problems with Delta-Matroid Constraints</strong>, SIAM Journal on Discrete Mathematics. 28 (2014) 942–961 <a href="https://doi.org/10.1137/110860070">10.1137/110860070</a>.</p>
</div>
<div id="ref-HefnerK95">
<p>[2] A. Hefner, P. Kleinschmidt, <strong>A constrained matching problem</strong>, Annals of Operations Research. 57 (1995) 135–145 <a href="https://doi.org/10.1007/BF02099694">10.1007/BF02099694</a>.</p>
</div>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-06-18">2019-06-18</time>. </div>
    <div class="info">Tags: Optimization, algorithm, airline.</div>
</div>]]></description>
    <pubDate>Tue, 18 Jun 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-06-18-long-distance-couple-back-to-back-ticketing.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>An algorithm for covert back-to-back ticketing</title>
    <link>https://chaoxuprime.com/posts/2019-06-15-covert-back-to-back-ticketing.html</link>
    <description><![CDATA[<br />
<div>
<p><a href="https://en.wikipedia.org/wiki/Airline_booking_ploys">Airline booking ploys</a> are ways to circumventing airlines ticket rules in order to spend less on the ticket. We consider a special case, the back-to-back ticketing/nested ticketing. <a href="https://www.tripsavvy.com/back-to-back-ticketing-468287">TripSavvy has a good article on back-to-back ticketing</a>.</p>
<p>For many airlines, back-to-back ticketing is explicitly forbidden, this includes <a href="https://www.aa.com/i18n/customer-service/support/conditions-of-carriage.jsp?anchorEvent=false&amp;from=footer?#ticketvalidity">American Airlines</a>, <a href="https://www.delta.com/us/en/booking-information/fare-classes-and-tickets/ticket-rules-restrictions">Delta</a> and <a href="https://www.united.com/ual/en/us/fly/contract-of-carriage.html">United</a>.</p>
<p>We want to model back-to-back ticketing into an algorithmic problem. There is a sequence of trips between two locations, and it can be grouped into different round trips. Each round trip itinerary has a different cost. A round trip itinerary is no more than a matching between two trips.</p>
<p>This can be seen as simple matching problem. The vertices are trips, which we can assume a trip means “traveling from A to B on date x”. There is an edge between two trips, if there is a round trip itinerary containing the trips. The cost of the edge is the cost of buying a round trip for those two trips. Since it is also possible that we buy a one-way ticket, there are also self-loops. Also, we can consider a multigraph, where the edges are colored. Each color class represents an airline.</p>
<p>If one does not care about the airline finding out, it is just a minimum weight perfect matching problem allowing self-loops. However, people might actually care about airline not happy about this practice. Hence we are interested in making sure in each airline, we have no overlapping itineraries. However, we do allow overlapping itineraries across airlines.</p>
<p>For two edges <span class="math inline">\set{a,b}</span> and <span class="math inline">\set{c,d}</span> defined over integers, it is <em>independent</em> if <span class="math inline">[a,b]\cap [c,d]= \emptyset</span>. A set of edges is <em>independent</em> if the edges are pairwise independent.</p>
<div class="theorem-environment Problem" data-index="1" type="Problem" title="Covert back-to-back ticketing problem">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">Covert back-to-back ticketing problem</span></span>
<p><strong>Input:</strong> A multigraph <span class="math inline">G=(V,E)</span> where <span class="math inline">V\subseteq [n]</span>, each edge can be one of <span class="math inline">k</span> colors, and there is an edge cost function <span class="math inline">c:E\to \R^+</span>.</p>
<p><strong>Output:</strong> A perfect matching <span class="math inline">M</span> (allowing self-loops), such that each color class of <span class="math inline">M</span> is independent, and the cost is minimized.</p>
</div>
<p>I suspect for arbitrary <span class="math inline">k</span>, the problem is NP-hard. We show how to solve the problem in polynomial time for <span class="math inline">k=2</span>.</p>
<p><a href="https://yizhis.github.io/">Yizhi Song</a> stated the idea that if one edge in a color is picked, it forces some edges of the other color to be picked. We can use the idea to obtain an <span class="math inline">O(n^3)</span> time algorithm for this problem.</p>
<p>Since we are only working with <span class="math inline">k=2</span> case, we will let <span class="math inline">\bar{a}</span> to be the color that is not <span class="math inline">a</span>. Recall <span class="math inline">[n]=\set{1,\ldots,n}</span> and <span class="math inline">[a..b] = \set{a,a+1,\ldots,b}</span>. We assume the vertices <span class="math inline">V=[n]</span>. For a graph with <span class="math inline">k</span> color classes, we define <span class="math inline">G_a</span> to be the subgraph consists of all edges of color <span class="math inline">a</span>. <span class="math inline">c_a(x,y)</span> is the cost of a color <span class="math inline">a</span> edge <span class="math inline">xy</span>. We define <span class="math inline">D(a,y,z)</span> as the optimal solution when the input graph is <span class="math inline">G_{\bar{a}}[[z-1]\setminus \set{y}] \cup G_a[[y-1]]</span>. Intuitively, this is the optimal solution where we need to match all vertices in <span class="math inline">Z = [z-1] \setminus \set{y}</span>, but can only use <span class="math inline">a</span> colored that is fully contained in <span class="math inline">[y-1]</span>, and <span class="math inline">\bar{a}</span> colored edges fully contained <span class="math inline">Z</span>. We also define <span class="math inline">C_{a}(x,y)</span> to be the optimal solution when the input graph is <span class="math inline">G_a[[x..y]]</span>. Namely, a min-cost perfect matching covering all vertices <span class="math inline">[x..y]</span> but we can only use <span class="math inline">a</span> colored edges contained in <span class="math inline">[x..y]</span>.</p>
<p>The optimal solution is <span class="math inline">D(a,n+1,n+1)</span> for either color <span class="math inline">a</span>.</p>
<p>We express the recursive relation. For <span class="math inline">y&lt;z</span>, we have the following. <span class="math display">
D(a,y,z) =\min \begin{cases}
\min_{x&lt;y} \set{ C_{\bar{a}}(y+2,z-1) + c_{\bar{a}}(x,y+1) + D(\bar{a},x,y)}\\
C_{\bar{a}}(y+1,z-1) + D(\bar{a},y,y)
\end{cases}
</span> It might be beneficial to see the intuition behind the two cases through the following pictures.</p>
<figure>
<img src="/files/ticketing_case1.png" alt="" /><figcaption>First case.</figcaption>
</figure>
<figure>
<img src="/files/ticketing_case2.png" alt="" /><figcaption>Second case.</figcaption>
</figure>
<p>On the other hand, when <span class="math inline">y=z</span> <span class="math display">
D(a,y,y) =\min_{x&lt;y} \set{
D(a,x,y) + c_a(x,y),
D(\bar{a},x,y) + c_{\bar{a}}(x,y)}
</span> One can easily infer the base case through definition. Note that all values of <span class="math inline">C_a</span> can be computed in <span class="math inline">O(n^2)</span> time. It takes <span class="math inline">O(n)</span> time to compute one value in <span class="math inline">D</span>. Therefore, the total running time is <span class="math inline">O(n^3)</span>.</p>
<p>One can show that even with <span class="math inline">k</span> different airlines, there is an algorithm with running time <span class="math inline">O(n^{O(k)})</span>.</p>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-06-15">2019-06-15</time>. </div>
    <div class="info">Tags: Optimization, algorithm, airline.</div>
</div>]]></description>
    <pubDate>Sat, 15 Jun 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-06-15-covert-back-to-back-ticketing.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Arrays and permutation</title>
    <link>https://chaoxuprime.com/posts/2019-06-15-array-and-permutation.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="permutation-functional-form"><span class="header-section-number">1</span> Permutation, functional form</h1>
<p>What exactly is an array. In functional form, an array just have to support the following two operations in constant time.</p>
<ol type="1">
<li><span class="math inline">get(A,i)</span>: returns <span class="math inline">A[i]</span>.</li>
<li><span class="math inline">set(A,i,x)</span>: update the array <span class="math inline">A</span> such that <span class="math inline">A[i]</span> returns <span class="math inline">x</span>.</li>
</ol>
<p>So in some sense, array is just encoding a function <span class="math inline">f:[n]\to X</span>. A permutation would be a bijective function <span class="math inline">\pi:[n]\to [n]</span>. If we are interested in applying a permutation <span class="math inline">\pi</span>, then to program it is easy, we need to output a new function <span class="math inline">g</span> such that <span class="math inline">g(i) = f(\pi(i))</span>.</p>
<p>This allows us to apply permutations pretty easily by composing functions and cache outputs. In the purely functional view, the layout of the array in memory and the indexing can be different.</p>
<h1 id="permutation-physically"><span class="header-section-number">2</span> Permutation, physically</h1>
<p>Sometimes one might ask to physically apply the permutation to an array. That is, the <span class="math inline">i</span>th position in the array contains the element in <span class="math inline">\pi(i)</span>. This is helpful because it helps with cache locality: accessing consecutive elements would be in the same location. Although if the ordering of loops does not matter, there is no harm considering the functional view.</p>
<p>Often, one is tasked to apply permutation to an array physically. It usually ask for <span class="math inline">O(n)</span> running time and <span class="math inline">O(1)</span> space. Unfortunately, there is no way to obtain this running time for all permutations. There are some permutations where this is impossible. <a href="https://cstheory.stackexchange.com/questions/6711/complexity-of-applying-a-permutation-in-place">A discussion can be found in cstheory</a>.</p>
<h1 id="mix-and-match"><span class="header-section-number">3</span> Mix and match</h1>
<p><a href="https://www.linkedin.com/in/lingyu-xu-9b87a565/">Lingyu Xu</a> asked me about <a href="https://leetcode.com/problems/wiggle-sort-ii/">Wiggle Sort</a>, where the actual <strong>physical layout</strong> has to be changed, but it takes both the functional and physical view of the array.</p>
<p>Let’s consider the simple case where every element is distinct. One simple solution is the following. Partition the numbers into the median, elements smaller than median, and elements larger than the median. We map the smallest <span class="math inline">n/2</span> elements into even positions, and remaining elements into the odd position. The algorithm has <span class="math inline">O(n)</span> time. The problem is how to get constant extra place. Because it is unclear how to apply the following permutation in place. The permutation <span class="math inline">\sigma(i) = (1+2i) \% (n|1)</span>.</p>
<p>However, one we take the functional view, the problem can be solved, physically too. The <a href="https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/ono1-after-median-virtual-indexing/81756">answer by</a> <a href="http://www.stefan-pochmann.info/">Stefan Pochmann</a> shows one can simply do the mapping in place.</p>
<p>What is happening in the physical location. If we applied index transform <span class="math inline">\pi</span>, then apply physical permutation <span class="math inline">\sigma</span> on the index, what happens for the physical array? It is the same as applying <span class="math inline">\pi^{-1}\sigma\pi</span> to the physical array. Note this means we can only use this trick to obtain conjugates of <span class="math inline">\sigma</span>.</p>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-06-15">2019-06-15</time>. </div>
    <div class="info">Tags: Permutation.</div>
</div>]]></description>
    <pubDate>Sat, 15 Jun 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-06-15-array-and-permutation.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Union of intervals in SQL</title>
    <link>https://chaoxuprime.com/posts/2019-04-27-union-of-intervals-in-sql.html</link>
    <description><![CDATA[<br />
<div>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>We given a collection of <span class="math inline">n</span> intervals, and we want to find its union, represented by a set of disjoint intervals. Assume the intervals are of the form <span class="math inline">[a,b)</span>, where <span class="math inline">a&lt;b</span>. However, I have to solve this problem in Hive. So this is a problem I have to solve in Hive’s SQL variant.</p>
<p>First, here is the schema of the table and some sample inputs.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> t (</span>
<span id="cb1-2"><a href="#cb1-2"></a>  a <span class="dt">int</span>,</span>
<span id="cb1-3"><a href="#cb1-3"></a>  b <span class="dt">int</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>);</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">INSERT</span> <span class="kw">INTO</span> t <span class="kw">VALUES</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  (<span class="dv">0</span>,<span class="dv">10</span>),</span>
<span id="cb1-7"><a href="#cb1-7"></a>  (<span class="dv">20</span>,<span class="dv">30</span>),</span>
<span id="cb1-8"><a href="#cb1-8"></a>  (<span class="dv">5</span>,<span class="dv">15</span>);</span></code></pre></div>
<p>The correct output should be the following.</p>
<pre><code>a    b
-------
0    15
20   30</code></pre>
<p>We do not allow empty intervals, so we cannot have <span class="math inline">a=b</span>.</p>
<h1 id="previous-works"><span class="header-section-number">2</span> Previous Works</h1>
<p>Note this is a common interview problem, <a href="https://leetcode.com/problems/merge-intervals/">LeetCode 56. Merge Intervals</a>. There is a <span class="math inline">\Omega(n\log n)</span> running time lower bound. There is an <span class="math inline">O(n\log p)</span> upper bound, where <span class="math inline">p</span> is the number of points required to stab all intervals. In higher dimension, this is called the <a href="https://en.wikipedia.org/wiki/Klee%27s_measure_problem">Klee’s measure problem</a>.</p>
<p>However, one would wonder how efficient can we solve the problem in SQL. I was surprised find a <a href="https://stackoverflow.com/a/8120432/303863">very short solution on stackoverflow</a>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">SELECT</span> </span>
<span id="cb3-2"><a href="#cb3-2"></a>       t1.a,</span>
<span id="cb3-3"><a href="#cb3-3"></a>       <span class="fu">MIN</span>(t2.b) <span class="kw">AS</span> b</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">FROM</span> t t1 </span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">INNER</span> <span class="kw">JOIN</span> t t2 <span class="kw">ON</span> t1.a <span class="op">&lt;=</span> t2.b</span>
<span id="cb3-6"><a href="#cb3-6"></a>  <span class="kw">AND</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span>(<span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> t </span>
<span id="cb3-7"><a href="#cb3-7"></a>                 <span class="kw">WHERE</span> t2.b <span class="op">&gt;=</span> t.a <span class="kw">AND</span> t2.b <span class="op">&lt;</span> t.b) </span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="kw">WHERE</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span>(<span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> t</span>
<span id="cb3-9"><a href="#cb3-9"></a>                 <span class="kw">WHERE</span> t1.a <span class="op">&gt;</span> t.a <span class="kw">AND</span> t1.a <span class="op">&lt;=</span> t.b) </span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="kw">GROUP</span> <span class="kw">BY</span> t1.a</span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="kw">ORDER</span> <span class="kw">BY</span> t1.a</span></code></pre></div>
<p>Unfortunately, the performance is not promising. Indeed, this is a <span class="math inline">O(n^2)</span> time algorithm. After generating <span class="math inline">10000</span> random intervals in PostgreSQL, it took 13 seconds to run. Also making it work in Hive is next to impossible due to Hive’s limitations on joins and subqueries.</p>
<p><a href="http://tsql.solidq.com/">Itzik Ben-Gan</a> has <a href="https://www.itprotoday.com/development-techniques-and-management/packing-date-intervals">written</a> <a href="https://blogs.solidq.com/en/sqlserver/packing-intervals/">multiple</a> <a href="https://www.itprotoday.com/sql-server/new-solution-packing-intervals-problem">articles</a> on how to solve this problem. I recommend reading them to learn various tricks. In fact, my solution here is quite similar to one of Ben-Gan’s.</p>
<p>Thanks to <a href="https://scholar.google.com/citations?user=jB4qJYEAAAAJ&amp;hl=en">Peng Yu</a> who pointed out this kind of queries is very common in sessionization.</p>
<h1 id="using-basic-sql"><span class="header-section-number">3</span> Using basic SQL</h1>
<p>Here we will try to implement an algorithm using the most basic of SQL, so it would even work in Hive.</p>
<h2 id="solution-by-simulate-the-standard-sweep-line-algorithm"><span class="header-section-number">3.1</span> Solution by simulate the standard sweep-line algorithm</h2>
<p>We first build a table, such that <span class="math inline">(a,c)</span> is in the table shows that there are <span class="math inline">c</span> intervals the endpoint directly before <span class="math inline">a</span>. Next, we notice that <span class="math inline">c=0</span> if and only if <span class="math inline">a</span> is the start of a new interval in the union. Hence we can assign everything between consecutive <span class="math inline">c=0</span> a name.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">WITH</span> </span>
<span id="cb4-2"><a href="#cb4-2"></a>  weighted_endpoints <span class="kw">AS</span> (</span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="kw">SELECT</span> a, <span class="fu">Sum</span>(d) <span class="kw">AS</span> d</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="kw">FROM</span>   (<span class="kw">SELECT</span> a,  <span class="dv">1</span> <span class="kw">AS</span> d <span class="kw">FROM</span> t</span>
<span id="cb4-5"><a href="#cb4-5"></a>            <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>            <span class="kw">SELECT</span> b, <span class="op">-</span><span class="dv">1</span> <span class="kw">AS</span> d <span class="kw">FROM</span> t) e</span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">GROUP</span>  <span class="kw">BY</span> a),</span>
<span id="cb4-8"><a href="#cb4-8"></a>  endpoints_with_coverage <span class="kw">AS</span> (</span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="kw">SELECT</span> <span class="op">*</span>, <span class="fu">Sum</span>(d) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="op">-</span> d <span class="kw">AS</span> c</span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="kw">FROM</span> weighted_endpoints),</span>
<span id="cb4-11"><a href="#cb4-11"></a>  equivalence_classes <span class="kw">AS</span> (</span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="kw">SELECT</span> a, <span class="fu">COUNT</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> c<span class="op">=</span><span class="dv">0</span> <span class="cf">THEN</span> <span class="dv">1</span> <span class="cf">END</span>) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> <span class="kw">class</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="kw">FROM</span> endpoints_with_coverage)</span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="kw">SELECT</span> <span class="fu">min</span>(a) <span class="kw">AS</span> a, <span class="fu">max</span>(a) <span class="kw">AS</span> b</span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="kw">FROM</span> equivalence_classes</span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">class</span>;</span></code></pre></div>
<p>The equivalence classes idea is from Peng Yu. This code took 100ms to handle 10000 random intervals in PostgreSQL. You can find <a href="https://www.db-fiddle.com/f/aVaF6NDTVYmxBpifsHDFBf/9">the example in DB-fiddle</a>. I am interested to seeing simpler and faster code using the simplest of SQL.</p>
<h2 id="solution-through-gaps"><span class="header-section-number">3.2</span> Solution through gaps</h2>
<p>There is another solution, which uses the idea of gaps. Interestingly, gaps are much easier to compute. Here we modify <a href="https://stackoverflow.com/a/53163029/303863">Oleg K’s solution</a>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">WITH</span> largest_prev <span class="kw">AS</span> (<span class="kw">SELECT</span> </span>
<span id="cb5-2"><a href="#cb5-2"></a>                      <span class="fu">MAX</span>(b) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> b,</span>
<span id="cb5-3"><a href="#cb5-3"></a>                      <span class="fu">LEAD</span>(a) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> a </span>
<span id="cb5-4"><a href="#cb5-4"></a>                      <span class="kw">FROM</span> t),</span>
<span id="cb5-5"><a href="#cb5-5"></a>     gaps <span class="kw">AS</span> (<span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> largest_prev <span class="kw">WHERE</span> b<span class="op">&lt;</span>a</span>
<span id="cb5-6"><a href="#cb5-6"></a>              <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>              <span class="kw">SELECT</span> <span class="fu">min</span>(a), <span class="fu">min</span>(a) <span class="kw">from</span> t</span>
<span id="cb5-8"><a href="#cb5-8"></a>              <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>              <span class="kw">SELECT</span> <span class="fu">max</span>(b), <span class="kw">null</span> <span class="kw">from</span> t),</span>
<span id="cb5-10"><a href="#cb5-10"></a>     intervals <span class="kw">AS</span> (<span class="kw">SELECT</span> a, <span class="fu">LEAD</span>(b) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> b) <span class="kw">as</span> b <span class="kw">FROM</span> gaps)</span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> intervals <span class="kw">WHERE</span> a <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">null</span>;</span></code></pre></div>
<p>This one can also be tested on <a href="https://www.db-fiddle.com/f/k1GTRiRgaiPmRfxZoWBhTs/1">DB-fiddle</a>. This code took 70ms to handle 10000 random intervals in PostgreSQL.</p>
<p>As a real application, for example, if we want to know the length of union of intervals grouped by some keys. The following is how we do it in hive. Note in this application, we don’t have to remove the null rows because we are taking a sum.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">SET</span> hivevar<span class="ch">:key</span><span class="op">=</span>id1,id2;</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">SET</span> hivevar<span class="ch">:input</span><span class="op">=</span>t;</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">WITH</span> largest_prev <span class="kw">AS</span> (<span class="kw">SELECT</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>                      ${<span class="kw">key</span>},</span>
<span id="cb6-5"><a href="#cb6-5"></a>                      <span class="fu">MAX</span>(b) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> ${<span class="kw">key</span>} <span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> b,</span>
<span id="cb6-6"><a href="#cb6-6"></a>                      <span class="fu">LEAD</span>(a) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> ${<span class="kw">key</span>} <span class="kw">ORDER</span> <span class="kw">BY</span> a) <span class="kw">AS</span> a</span>
<span id="cb6-7"><a href="#cb6-7"></a>                      <span class="kw">FROM</span> ${input}),</span>
<span id="cb6-8"><a href="#cb6-8"></a>     gaps <span class="kw">AS</span> (<span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> largest_prev <span class="kw">WHERE</span> b<span class="op">&lt;</span>a</span>
<span id="cb6-9"><a href="#cb6-9"></a>              <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>              <span class="kw">SELECT</span> ${<span class="kw">key</span>}, <span class="fu">min</span>(a), <span class="fu">min</span>(a) <span class="kw">from</span> ${input} <span class="kw">GROUP</span> <span class="kw">BY</span> ${<span class="kw">key</span>}</span>
<span id="cb6-11"><a href="#cb6-11"></a>              <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>              <span class="kw">SELECT</span> ${<span class="kw">key</span>}, <span class="fu">max</span>(b), <span class="kw">null</span> <span class="kw">from</span> ${input} <span class="kw">GROUP</span> <span class="kw">BY</span> ${<span class="kw">key</span>}),</span>
<span id="cb6-13"><a href="#cb6-13"></a>     intervals <span class="kw">AS</span> (<span class="kw">SELECT</span> ${<span class="kw">key</span>}, </span>
<span id="cb6-14"><a href="#cb6-14"></a>                          a,</span>
<span id="cb6-15"><a href="#cb6-15"></a>                          <span class="fu">LEAD</span>(b) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> ${<span class="kw">key</span>} <span class="kw">ORDER</span> <span class="kw">BY</span> b) <span class="kw">as</span> b</span>
<span id="cb6-16"><a href="#cb6-16"></a>                   <span class="kw">FROM</span> gaps)</span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="kw">SELECT</span> ${<span class="kw">key</span>}, <span class="fu">SUM</span>(b<span class="op">-</span>a) <span class="kw">as</span> score</span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="kw">FROM</span> intervals</span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="kw">GROUP</span> <span class="kw">BY</span> ${<span class="kw">key</span>};</span></code></pre></div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-04-27">2019-04-27</time>. </div>
    <div class="info">Tags: SQL, algorithm.</div>
</div>]]></description>
    <pubDate>Sat, 27 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-04-27-union-of-intervals-in-sql.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Maximum weight hierarchical $b$-matching</title>
    <link>https://chaoxuprime.com/posts/2019-04-27-maximum-weight-hierarchical-b-matching.html</link>
    <description><![CDATA[<br />
<div>
<p>We consider the following problem, which appeared in <span class="citation" data-cites="EmekKSZ19">[<a href="#ref-EmekKSZ19" role="doc-biblioref">1</a>]</span>.</p>
<p>Let <span class="math inline">\mathcal{L}</span> be a laminar family consists of sets <span class="math inline">F_1,\ldots,F_k</span>. Let <span class="math inline">u_1,\ldots,u_k</span> to be positive integers. Consider a graph <span class="math inline">G=(V,E)</span> with a weight function <span class="math inline">w:E\to \N</span> and capacity function <span class="math inline">c:E\to \N</span>. We are interested in finding a <span class="math inline">y\leq c</span>, such that for every <span class="math inline">F_i\in \mathcal{L}</span>, we have <span class="math inline">\sum_{v\in F_i} \sum_{e:v\in e\in E} y_e \leq u_i</span>, and <span class="math inline">\sum_{e\in E} y_ew_e</span> is maximized.</p>
<p>Formally, it is the following integer program.</p>
<p><span class="math display">
\begin{aligned}
&amp; \max_{y\in \Z^m} &amp; &amp; \sum_{e} w_e y_e &amp; \\
&amp; \text{s.t.} &amp; &amp; \sum_{v\in F_i} \sum_{e:v\in e\in E} y_e \leq u_i &amp; i\in [k] \\
&amp; &amp; &amp;  0\leq y_e \leq c_e &amp; \forall e\in E \\
\end{aligned}
</span></p>
<p>This is a generalization of the maximum weight <span class="math inline">c</span>-capacitated <span class="math inline">b</span>-matching problem. Indeed, we can simply set <span class="math inline">F_i = \set{v_i}</span> and <span class="math inline">u_i=b_i</span>. However, this problem is actually no more general than the maximum weight <span class="math inline">c</span>-capacitated <span class="math inline">b</span>-matching problem.</p>
<p>Let <span class="math inline">A \in \Z^{m\times n}</span> be a matrix such that <span class="math inline">\sum_{i=1}^m |A_{i,j}|\leq 2</span> for every <span class="math inline">j</span>. We call <span class="math inline">A</span> a bidirected matrix.</p>
<div class="theorem-environment Theorem" data-index="1" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">1</span></span>
<p>Given <span class="math inline">A \in \Z^{m\times n}</span> a bidirected matrix and vectors <span class="math inline">a,b\in \Z^m</span>, <span class="math inline">c,d,w\in \Z^n</span>. The integer program <span class="math inline">\max_{x\in \Z^n} \set{wx \mid a\leq Ax\leq b, c\leq x\leq d}</span> can be solved in polynomial time. In particular, it is equivalent to the maximum weight <span class="math inline">b</span>-matching problem on graph of size <span class="math inline">poly(m,n)</span>.</p>
</div>
<p>The above theorem can be found in <span class="citation" data-cites="Schrijver03">[<a href="#ref-Schrijver03" role="doc-biblioref">2</a>]</span>. Note that in Schrijver’s book, one requires <span class="math inline">\sum_{i=1}^m |A_{i,j}|=2</span>. It is not hard to see the statement still holds even if we have <span class="math inline">\leq</span> in place of <span class="math inline">=</span>.</p>
<p>We will express the maximum weight hierarchical <span class="math inline">b</span>-matching problem as an integer program over a polytope defined over a bidirected matrix. The integer program is a modification of the integer program in <span class="citation" data-cites="KaparisLM17">[<a href="#ref-KaparisLM17" role="doc-biblioref">3</a>]</span>. The integer program here is simpler, because we are not trying to reduce to <em>perfect</em> <span class="math inline">b</span>-matching.</p>
<p>We define <span class="math inline">F_i&#39; = F_i \setminus \bigcup_{j: F_j\subsetneq F_i} F_j</span>. We also define <span class="math inline">C_i</span> to be the indices <span class="math inline">j</span>, such that for all <span class="math inline">k</span>, <span class="math inline">F_j\subseteq F_k \subsetneq F_i</span> implies <span class="math inline">j=k</span>. <span class="math inline">y_e</span> denote the amount of capacities we assign to <span class="math inline">e</span>, <span class="math inline">x_v</span> denotes the capacitated degree, hence <span class="math inline">x_v = \sum_{e:v\in e\in E} y_e</span>. We define <span class="math inline">z_i = \sum_{v\in F_i} x_v</span>, which can be transformed to <span class="math inline">z_i = \sum_{v\in F_i&#39;} x_v + \sum_{j\in C_i} z_j</span>. Therefore we obtain the following integer program by directly applying substitutions.</p>
<p><span class="math display">
\begin{aligned}
&amp; \max_{x\in \Z^n,y\in \Z^m, z\in \Z^k} &amp; &amp; \sum_{e} w_e y_e &amp; \\
&amp; \text{s.t.} &amp; &amp; \sum_{v\in F_i&#39;} x_v + \sum_{j\in C_i} z_j - z_i= 0 &amp; i\in [k] \\
&amp; &amp; &amp;  \sum_{e: v\in e\in E} y_e -x_v = 0 &amp; \forall v\in V \\
&amp; &amp; &amp;  0\leq y_e \leq c_e &amp; \forall e\in E \\
&amp; &amp; &amp;  0\leq z_i \leq u_i &amp; \forall i\in [k] \\
\end{aligned}
</span></p>
<p>The matrix here is a bidirected matrix. This shows the original problem can be solved in polynomial time.</p>
<h1 id="bibliography" class="unnumbered">References</h1>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-EmekKSZ19">
<p>[1] Y. Emek, S. Kutten, M. Shalom, S. Zaks, <strong>Hierarchical b-Matching</strong>, arXiv E-Prints. (2019) arXiv:1904.10210.</p>
</div>
<div id="ref-Schrijver03">
<p>[2] A. Schrijver, <strong>Combinatorial Optimization (3 volume, A, B, &amp; C)</strong>, Springer, 2003.</p>
</div>
<div id="ref-KaparisLM17">
<p>[3] I.M. Konstantinos Kaparis Adam N. Letchford, <strong>On matroid parity and matching polytopes</strong>, Department of Management Science, Lancaster University, 2017.</p>
</div>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxuprime.com">Chao Xu</a> on <time datetime="2019-04-27">2019-04-27</time>. </div>
    <div class="info">Tags: combinatorial optimization, matching, matroid.</div>
</div>]]></description>
    <pubDate>Sat, 27 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxuprime.com/posts/2019-04-27-maximum-weight-hierarchical-b-matching.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>

    </channel>
</rss>
