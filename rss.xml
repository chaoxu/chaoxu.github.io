<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>The Art Gallery Guardian</title>
        <link>https://chaoxu.prof</link>
        <description><![CDATA[Mostly notes on algorithms]]></description>
        <atom:link href="https://chaoxu.prof/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 06 Feb 2022 00:00:00 UT</lastBuildDate>
        <item>
    <title>The related employer controlled group</title>
    <link>https://chaoxu.prof/posts/2022-02-06-related-companies-and-controlled-groups.html</link>
    <description><![CDATA[<br />
<div>
<p>Disclaimer: Not an accountant nor a lawyer.</p>
<p>For employees in the US, employers (not just the employee) can
contribute to the employee’s retirement fund 401(k). There is an maximum
limit. It is <span class="math inline">M = \$61,000</span> for 2022.</p>
<p>If a person works for multiple <em>unrelated</em> employers, each
employer, in theory, can contribute <span class="math inline">M</span>
to their 401(k). This is because such limit is based on the plan, and
not based on the person.</p>
<p>See <a
href="https://www.kitces.com/blog/coordinating-contributions-multiple-employer-sponsored-defined-contribution-plans-401k-defined-benefit/">Michael
Kitces’s excellent article about the problem</a>.</p>
<p>Kitce’s article outlined there are two ways to determine if some
entities are related. Here we focus on the easier one, the controlled
group. Another good source for controlled groups is <a
href="https://www.betterment.com/401k/resources/controlled-groups">betterment’s
article</a>.</p>
<p>We will be very specific about the statement, what is
<em>unrelated</em>? Unfortunately. What IRS defined as controlled group
does not give us a equivalence relation. So here is an overview of what
is actually happening.</p>
<p>The IRS produce rules that group companies into sets of what is
called controlled groups. The idea is these companies are controlled by
the same entity. So they could as well be made into a single company. So
if they are a single company, they should not be contributing more than
<span class="math inline">M</span> to a employers 401(k).</p>
<p>However, there are overlap of the groups. So a partition must be
created. This partition, which I call it the controlled partition, need
to have the property that each partition class is a subset of some
controlled group.</p>
<p><a href="https://www.law.cornell.edu/uscode/text/26/1563">The actual
code states what to do with the overlaps</a>.</p>
<blockquote>
<p>The determination as to the group of which such corporation is a
component member shall be made under regulations prescribed by the
Secretary which are consistent with the purposes of this part.</p>
</blockquote>
<p>If a person works for companies that spans <span
class="math inline">k</span> different classes of the controlled
partition, then the employers in each partition class can contribute at
most <span class="math inline">M</span> to the person’s 401(k).</p>
<p>Now, we want to distill the information to a mathematically formal
one.</p>
<p>Consider we have a directed graph. The edges has a weight function
<span class="math inline">w:V\times V \to [0,1]</span>. Note for
simplicity of exposition, <span class="math inline">w(a,b)</span> for an
edge that doesn’t exists is defined as <span
class="math inline">0</span>. For each vertex, it satisfies sum of the
weight of in edges is at most <span class="math inline">1</span>.</p>
<p>The intuition is <span class="math inline">w(a,b)</span> means the
proportion of <span class="math inline">b</span> that is owned by <span
class="math inline">a</span>.</p>
<p>There is a special subset of vertices <span
class="math inline">U</span>. It correspond to individual, trusts and/or
estates.</p>
<p>We define a few terms.</p>
<ol type="1">
<li>A set <span class="math inline">S</span> of entities is a P-set, if
<span class="math inline">S</span> have the following property.</li>
</ol>
<ul>
<li>there exists a special vertex <span class="math inline">p\in
S</span>, called the parent.</li>
<li><span class="math inline">\sum_{u\in S} w(uv) \geq 0.8</span> for
all <span class="math inline">v\in S\setminus \set{p}</span>.</li>
<li><span class="math inline">w(pv)\geq 0.8</span> for at least two
distinct vertices in <span class="math inline">S\setminus
\set{p}</span>.</li>
</ul>
<ol start="2" type="1">
<li>A set <span class="math inline">S</span> is a B-set, if <span
class="math inline">|S|\geq 2</span>, and there exists a set <span
class="math inline">T\subseteq U</span> such that <span
class="math inline">|T|\leq 5</span>, and</li>
</ol>
<ul>
<li><span class="math inline">\sum_{t\in T} w(tv)\geq 0.8</span> for
each <span class="math inline">v\in S</span>,</li>
<li><span class="math inline">\sum_{t\in T} \min_{v\in S} \set{w(tv)}
\geq 0.5</span>.</li>
</ul>
<ol start="3" type="1">
<li>A set <span class="math inline">S</span> is a C-set, if <span
class="math inline">|S|\geq 3</span> and</li>
</ol>
<ul>
<li>for each <span class="math inline">v\in S</span>, <span
class="math inline">v</span> is in a P-set contained in <span
class="math inline">S</span>, or a B-set contained in <span
class="math inline">S</span>.</li>
<li>at least one vertex <span class="math inline">v\in S</span> is a
parent vertex of some P-set contained in <span
class="math inline">S</span>, and is also a vertex of a B-set contained
in <span class="math inline">S</span>.</li>
</ul>
<p>The P-set, B-set and C-set reflects Parent-Subsidiary Controlled
Group, Brother-Sister Controlled Group and Combined Controlled Group,
respecitvely. Note I’m still simplfying here. There are some attribution
problems. For example, someone could own a trust which owns a company,
and this has to be taken into consideration for the controlled
groups.</p>
<p>Here I found a few useful facts.</p>
<ol type="1">
<li>It’s possible that two B-set <span class="math inline">A</span> and
<span class="math inline">B</span> intersects, but <span
class="math inline">A\cup B</span> is not a B-set:</li>
</ol>
<p>Consider there are two sets of size <span
class="math inline">5</span> in <span class="math inline">U</span>,
<span class="math inline">T_1</span> and <span
class="math inline">T_2</span>. <span class="math inline">|T_1\cap T_2|
= 1</span>.</p>
<p>Consider two sets <span class="math inline">A = \set{a,c}</span> and
<span class="math inline">B=\set{b,c}</span>. For each vertex <span
class="math inline">v\in T_1\setminus T_2</span>, there is an edge <span
class="math inline">va</span> with weight <span
class="math inline">7/40</span>, and edge <span
class="math inline">vc</span> with weight <span
class="math inline">1/20</span>. For each vertex <span
class="math inline">v\in T_2\setminus T_1</span>, there is an edge <span
class="math inline">vb</span> with weight <span
class="math inline">7/40</span>, and edge <span
class="math inline">vc</span> with weight <span
class="math inline">1/20</span>. For <span class="math inline">v\in
T_1\cap T_2</span>, there is an edge <span class="math inline">vc</span>
with weight <span class="math inline">3/5</span>, <span
class="math inline">va</span>, <span class="math inline">vb</span> with
weight <span class="math inline">3/10</span>.</p>
<p>The claim is that <span class="math inline">A</span> and <span
class="math inline">B</span> are both B-set, but <span
class="math inline">A\cup B</span> is not. This is because no subset of
<span class="math inline">T_1\cup T_2</span> with size no larger than
<span class="math inline">5</span> can make sure incoming weights for
each vertex in <span class="math inline">A\cup B</span> is at least
<span class="math inline">0.8</span>.</p>
<ol start="2" type="1">
<li><p><span class="math inline">A\subseteq B</span> and <span
class="math inline">B</span> is a B-set, then <span
class="math inline">A</span> is a B-set if <span
class="math inline">|A|\geq 2</span>.</p></li>
<li><p>Two P-sets <span class="math inline">A</span> and <span
class="math inline">B</span> such that <span class="math inline">A\cap
B\neq \emptyset</span>, then <span class="math inline">A\cup B</span> is
a P-set.</p></li>
</ol>
<p>This mean there is a unique maximal P-set containing a particular
vertex.</p>
<ol start="4" type="1">
<li>If any set is a C-set, then the union of all P-sets and B-sets is a
C-set.</li>
</ol>
<p>Looking at the letter of the law, any C-set together with some other
P-set and B-set is still a C-set. This means two companies that is not
related in any way can be classified to be related.</p>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2022-02-06">2022-02-06</time>. </div>
    <div class="info">Tags: tax, 401(k).</div>
</div>]]></description>
    <pubDate>Sun, 06 Feb 2022 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2022-02-06-related-companies-and-controlled-groups.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Test conjectures on $k$-partitions over submodular functions</title>
    <link>https://chaoxu.prof/posts/2022-01-30-test-conjectures-on-k-partitions.html</link>
    <description><![CDATA[<br />
<div>
<p>This article we consider tools one can use to quickly test
conjectures. Testing conjectures quickly run into realm of infeasibility
due to the combinatorial explosion. We look through an actual example
and learn a few techniques. We use <a
href="https://www.sagemath.org/">Sage</a> and any fast linear program
solver, like <a href="https://www.gurobi.com/">Gurobi</a>.</p>
<h1 data-number="1"
id="a-conjecture-on-k-partitions-of-submodular-function"><span
class="header-section-number">1</span> A conjecture on <span
class="math inline">k</span>-partitions of submodular function</h1>
<p>A set of <span class="math inline">k</span> non-empty and disjoint
sets that partitions <span class="math inline">V</span> is called a
<span class="math inline">k</span>-partition. Let <span
class="math inline">f:2^V\to \R</span> be a submodular function, a
minimum <span class="math inline">k</span>-partition is a <span
class="math inline">k</span>-partition <span
class="math inline">\mathcal{X}</span> of <span
class="math inline">V</span> such that <span
class="math inline">\sum_{X\in \mathcal{X}} f(X)</span> is
minimized.</p>
<p>A <span class="math inline">k</span>-partition <span
class="math inline">\mathcal{X}</span> and a <span
class="math inline">j</span>-partition <span
class="math inline">\mathcal{Y}</span> is noncrossing, if <span
class="math inline">X\subseteq Y</span> for some <span
class="math inline">X\in \mathcal{X}</span> and <span
class="math inline">Y\in \mathcal{Y}</span>. We denote it <span
class="math inline">\mathcal{X}\lhd\mathcal{Y}</span>.</p>
<p>For two partitions, <span class="math inline">\mathcal{X}\sqcap
\mathcal{Y} = \set{ X\cap Y | X\in \mathcal{X},
Y\in\mathcal{Y}}</span>.</p>
<p>For two partitions <span class="math inline">\mathcal{X}</span> and
<span class="math inline">\mathcal{Y}</span>, <span
class="math inline">\mathcal{X}\leq \mathcal{Y}</span> if for each <span
class="math inline">X\in\mathcal{X}</span>, <span
class="math inline">X\subseteq Y</span> for some <span
class="math inline">Y\in\mathcal{Y}</span>.</p>
<div class="theorem-environment Conjecture" data-index="1"
type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span
class="index">1</span></span>
<p><span class="math inline">f:2^V\to \R</span> is a submodular function
with <span class="math inline">|V|\geq k</span>. Let <span
class="math inline">\mathcal{X}</span> be a minimum <span
class="math inline">k-1</span>-partition and <span
class="math inline">\mathcal{Y}</span> be a minimum <span
class="math inline">k</span>-partition. There exists a minimum <span
class="math inline">k</span>-partition <span
class="math inline">\mathcal{Y}&#39;</span> such that <span
class="math inline">\mathcal{X}\lhd \mathcal{Y}&#39;</span> and <span
class="math inline">\mathcal{X}\sqcap \mathcal{Y} \leq
\mathcal{Y}&#39;</span>.</p>
</div>
<p>We are interested in writing a program to test the conjecture for
small <span class="math inline">k</span>. The idea is to find different
ways <span class="math inline">\mathcal{X}</span> can intersect with
<span class="math inline">\mathcal{Y}</span>, a matrix that encodes such
information are called configurations. For each configuration, we want
to know under such configuration, can we find the desired <span
class="math inline">\mathcal{Y}&#39;</span>.</p>
<h1 data-number="2" id="enumerate-non-isomorphic-configurations"><span
class="header-section-number">2</span> Enumerate non-isomorphic
configurations</h1>
<p>Given <span class="math inline">\mathcal{X} =
\set{X_1,\ldots,X_{k-1}}</span> and <span
class="math inline">\mathcal{Y} = \set{Y_1,\ldots,Y_{k}}</span>. Let
<span class="math inline">Z_{i,j} = X_i\cap Y_j</span>.</p>
<p>We want to show some <span
class="math inline">\mathcal{Y}&#39;</span> is a min <span
class="math inline">k</span>-partition, where each partition class of
<span class="math inline">\mathcal{Y}&#39;</span> has to be the union of
some <span class="math inline">Z_{i,j}</span>s.</p>
<p>It doesn’t matter if <span class="math inline">Z_{i,j}</span> has
<span class="math inline">100</span> or <span
class="math inline">1</span> vertices, only the emptyness matters.
Consider a matrix <span class="math inline">M_{i,j} =
\max(1,|Z_{i,j}|)</span>. Such a matrix is called a
<em>configuration</em>. Define two configurations are
<em>isomorphic</em>, if one can be obtained by swapping rows and columns
of the other.</p>
<p>We are interested in enumerate the possible configurations up to
isomorphism.</p>
<p>Find integer <span class="math inline">\set{0,1}</span> matrices and
then modulo the action of a permutation group (that defines the
isomorphism) can be done in Sage. There is a function that generates all
integer vectors modulo a permutation group, and the vectors has length
<span class="math inline">\ell</span> with elements in <span
class="math inline">\set{0,\ldots,n}</span>. See the reference on <a
href="https://doc.sagemath.org/html/en/reference/combinat/sage/combinat/integer_vectors_mod_permgroup.html">Integer
vectors modulo the action of a permutation group</a>.</p>
<pre><code>IntegerVectorsModPermutationGroup(P, max_part=1)</code></pre>
<p>Once we have the output, we filter the vectors to maintain the
required properties, for example, has at least a <span
class="math inline">1</span> on each row.</p>
<p>The input of the Sage function has to take the desired permutation
group <span class="math inline">P</span>.</p>
<p>One might think we just take <span class="math inline">S_{k-1}\times
S_k</span> to obtain <span class="math inline">P</span>, where <span
class="math inline">S_k</span> is the symmetric group of order <span
class="math inline">k</span>. Unfortunately, this is not correct. This
gives you the action on the rows and columns, but what we really need,
is what happens to each element in the matrix.</p>
<p>The correct way is to use the wreath products. We want to consider
<span class="math inline">S_{k-1} \wr S_k</span> intersect with <span
class="math inline">S_k \wr S_{k-1}</span>. However, we have to make
sure the mapping of the elements are correct. The following is the code
in SAGE, and the elements are numbers <span class="math inline">1</span>
to <span class="math inline">k(k-1)</span>. Note we made sure the
mapping has the same labels through permutation <code>pi</code>.</p>
<pre><code>a = SymmetricGroup(k-1)
b = SymmetricGroup(k)

matrix = [[k*x+y+1 for y in range(k-1)] for x in range(k)]
pi = list(itertools.chain.from_iterable(map(list, zip(*matrix))))

# we have to use SAGE to access GAP
GG = gap.WreathProduct(gap(a),gap(b))
HH = gap.WreathProduct(gap(b),gap(a))

G = PermutationGroup(gap_group = GG.AsPermGroup())
Hbad = PermutationGroup(gap_group = HH.AsPermGroup())
# make sure the elements are labelled correctly.
H = PermutationGroup([perm_replace(pi,g) for g in Hbad.gens()])

# The correct permutation group
P = H.intersection(G)</code></pre>
<p>At this point, we obtain all possible configurations. In particular,
for <span class="math inline">k=3,4,5,6</span>, the number of
configurations are <span class="math inline">13, 87, 1053,
28576</span>.</p>
<p>If we restrict to configurations where there is at least a <span
class="math inline">1</span> in each row and at least a <span
class="math inline">1</span> in each column, it cuts down the
configurations to <span class="math inline">5,42,633,20755</span>. We
can further observe that for some configurations, it implies <span
class="math inline">\mathcal{X}\lhd \mathcal{Y}</span> already, so we do
not have to check such configurations. Let’s call configurations after
the above filtering good configurations. The number of good
configurations for <span class="math inline">k=3,4,5,6</span> are <span
class="math inline">3, 23, 353, 12828</span>.</p>
<h1 data-number="3"
id="test-if-there-exists-a-noncrossing-mathcaly-for-a-configuration-m"><span
class="header-section-number">3</span> Test if there exists a
noncrossing <span class="math inline">\mathcal{Y}&#39;</span> for a
configuration <span class="math inline">M</span></h1>
<p>We now have a configuration <span class="math inline">M</span>, and
now we are interested in creating a linear program to decide if there
always exists a minimum <span class="math inline">k</span>-partition
<span class="math inline">\mathcal{Y}&#39;</span> that is non-crossing
with the minimum <span class="math inline">(k-1)</span>-partition <span
class="math inline">\mathcal{X}</span>. For a given <span
class="math inline">M</span>, one can always recover <span
class="math inline">\mathcal{X}</span> and <span
class="math inline">\mathcal{Y}</span>.</p>
<p>Let <span class="math inline">V</span> be the set of vertices, which
equals to the number of <span class="math inline">1</span>s in <span
class="math inline">M</span>. Let <span
class="math inline">P_k(V)</span> be the set of <span
class="math inline">k</span>-partitions of <span
class="math inline">V</span>. For each <span
class="math inline">U\subseteq V</span>, we create a variable <span
class="math inline">x_U</span>. It represents the value of <span
class="math inline">f(U)</span>. We also create a variable <span
class="math inline">z</span>.</p>
<p>For a partition <span class="math inline">\mathcal{S}</span>, <span
class="math inline">x_\mathcal{S}</span> is just <span
class="math inline">\sum_{S\in \mathcal{S}} x_S</span>.</p>
<p>Consider the following linear program.</p>
<p><span class="math display">
\begin{aligned}
&amp; \max        &amp; &amp; z &amp;\\
&amp; \text{s.t.} &amp; &amp; x_{S\cup \{a\}} + x_{S\cup \{b\}} \geq
x_{S\cup \{a,b\}} + x_{S} &amp; \forall S\subseteq V, a,b\in V\setminus
S\\
&amp;             &amp; &amp; x_\mathcal{X} \leq x_{\mathcal{X}&#39;}
&amp; \forall \mathcal{X}&#39;\in P_{k-1}(V)\\
&amp;             &amp; &amp; x_\mathcal{Y} \leq x_{\mathcal{Y}&#39;}
&amp; \forall \mathcal{Y}&#39;\in P_{k}(V)\\
&amp;             &amp; &amp; x_\mathcal{Y} = 1 &amp; \\
&amp;             &amp; &amp; z \leq x_{\mathcal{Y}&#39;} &amp; \forall
\mathcal{Y}&#39;\in P_{k}(V), \mathcal{X} \lhd \mathcal{Y}&#39;\\
\end{aligned}
</span></p>
<p>The first set of constraints are the submodular inequalities. The
second shows <span class="math inline">\mathcal{X}</span> is a minimum
<span class="math inline">k-1</span>-partition, and the third shows
<span class="math inline">\mathcal{Y}</span> is a minimum <span
class="math inline">k</span>-partition. We also set the value of the
minimum <span class="math inline">k</span>-partition to be <span
class="math inline">1</span>. Finally, we consider every <span
class="math inline">k</span>-partition that is non-crossing with <span
class="math inline">\mathcal{X}</span>, and <span
class="math inline">z</span> is a lower bound of their value.</p>
<p>If the objective value <span class="math inline">z=1</span>, then
this means there is at least <span class="math inline">1</span> <span
class="math inline">k</span>-partition <span
class="math inline">\mathcal{Y}&#39;</span> that is non-crossing with
<span class="math inline">\mathcal{X}</span> has the value same as the
minimum <span class="math inline">k</span>-partition. Therefore the
conjecture is true if and only for every configuration <span
class="math inline">M</span>, the above linear program has optimum <span
class="math inline">1</span>.</p>
<h1 data-number="4" id="redundant-constraints"><span
class="header-section-number">4</span> Redundant constraints</h1>
<p>One can easily prove the conjecture for <span
class="math inline">k=3,4</span> by directly using the above linear
program over all good configurations. However, it runs into difficulty
with <span class="math inline">k=5</span>. This is because the linear
program is way too large. The number of <span
class="math inline">k</span> partitions for <span
class="math inline">n</span> elements is the Stirling number of the
second kind <span class="math inline">\left\{{n\atop k}\right\}</span>.
<span class="math inline">\left\{{20\atop 5}\right\} =
749206090500</span> and <span class="math inline">\left\{{20\atop
4}\right\} = 45232115901</span>. However, it seems many constraints are
redundant due to symmetry. It be interesting to see if we can cut it
down to a manageable size. If so, maybe the conjecture for <span
class="math inline">k=5</span> or even <span
class="math inline">k=6</span> might be solvable.</p>
<p>To do this, we consider the following definition. Consider a vector
<span class="math inline">s=(s_1,\ldots,s_k)</span>. We say a family of
<span class="math inline">k</span>-partitions <span
class="math inline">\mathcal{F}</span> is <span
class="math inline">s</span>-complete, if <span
class="math inline">f(\mathcal{P})\geq f(\mathcal{Y})</span> for all
<span class="math inline">\mathcal{P}\in \mathcal{C}</span>, then <span
class="math inline">f(\mathcal{P})\geq f(\mathcal{Y})</span> for all
<span class="math inline">k</span>-partition <span
class="math inline">\mathcal{P}</span>. Here <span
class="math inline">\mathcal{Y}=\{Y_1,\ldots,Y_k\}</span> is a <span
class="math inline">k</span>-partition such that <span
class="math inline">|Y_i|=s_i</span>. Let <span
class="math inline">\lambda(s)</span> to be the size of the minimum
<span class="math inline">s</span>-complete family. So instead of
considering all <span class="math inline">k</span>-partitions for the
constraints, we just have to consider the <span
class="math inline">s</span>-complete family for some <span
class="math inline">s</span>. If <span
class="math inline">\lambda(s)</span> is very small, then there is hope
to solve the problem quickly.</p>
<p>Let <span class="math inline">t</span> be a <span
class="math inline">k</span>-tuple consists of only <span
class="math inline">d</span>’s, then we define <span
class="math inline">\lambda_k(d) = \lambda(t)</span>. It would be very
interesting to see how large <span
class="math inline">\lambda_k(d)</span> is.</p>
<p>As an example, we show a simple result on <span
class="math inline">\lambda(a,b)</span>.</p>
<div class="theorem-environment Theorem" data-index="2" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">2</span></span>
<p><span class="math inline">\lambda(a,b)\leq 2^a+2^b-3</span>.</p>
</div>
<div class="theorem-environment Proof" type="Proof">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>Indeed, let <span class="math inline">\mathcal{Y}=(Y_1,Y_2)</span>
consists of <span class="math inline">a</span> and <span
class="math inline">b</span> elements.</p>
<p>Consider the following family <span
class="math inline">\mathcal{F}</span>: For each non-empty set <span
class="math inline">S</span> such that either <span
class="math inline">S\subsetneq Y_1</span> or <span
class="math inline">S\subsetneq Y_2</span>, <span
class="math inline">(S,V-S)\in \mathcal{F}</span>. Also, let <span
class="math inline">\mathcal{Y}\in \mathcal{F}</span>.</p>
<p>So there are <span class="math inline">2^a-2 + 2^b-2 + 1</span> sets
in <span class="math inline">\mathcal{F}</span>.</p>
<p>Next, we show <span class="math inline">\mathcal{F}</span> is an
<span class="math inline">(a,b)</span>-complete family. Consider any
<span class="math inline">(X_1,X_2)</span> not in <span
class="math inline">\mathcal{F}</span> and consider the intersection
with <span class="math inline">(Y_1,Y_2)</span>. Let <span
class="math inline">Z_{i,j} = X_i\cap Y_j</span>.</p>
<p>Let <span class="math inline">|Z_{1,1}|=x</span> and <span
class="math inline">|Z_{2,1}|=y</span>, then we have <span
class="math inline">|Z_{1,2}|=a-x</span> and <span
class="math inline">|Z_{2,2}|=b-x</span>. Consider when all <span
class="math inline">Z_{i,j}</span> is non-empty.</p>
<p><span class="math display">\begin{align*}
\sum_{i=1}^2 \sum_{j=1}^2 f(X_i)+f(Y_j) &amp;=
2(f(X_1)+f(X_2)+f(Y_1)+f(Y_2))\\
                                        &amp;\geq \sum_{i=1}^2
\sum_{j=1}^2 f(Z_{i,j}) + f(X_i\cup Y_j)\\
                                        &amp;=\sum_{i=1}^2 \sum_{j=1}^2
f(Z_{i,j})+f(\bar{Z_{i,j}})\\
                                        &amp;\geq 4(f(Y_1)+f(Y_2))
\end{align*}</span></p>
<p>Which shows <span class="math inline">f(X_1)+f(X_2)\geq
f(Y_1)+f(Y_2)</span>.</p>
<p>Otherwise, if some <span class="math inline">Z_{i,j}</span> is empty,
then we have <span class="math inline">(X_1,X_2)=(Y_1,Y_2)\in
\mathcal{F}</span>.</p>
</div>
<p>In particular, <span class="math inline">\lambda_2(d)\leq
2^{d+1}</span>.</p>
<div class="theorem-environment Conjecture" data-index="3"
type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span
class="index">3</span></span>
<p><span class="math inline">\lambda_k(d) = O(k^d)</span>.</p>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2022-01-30">2022-01-30</time>. </div>
    <div class="info">Tags: Conjectures, computational experiments, submodular, partition.</div>
</div>]]></description>
    <pubDate>Sun, 30 Jan 2022 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2022-01-30-test-conjectures-on-k-partitions.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Yotta Savings and covering designs</title>
    <link>https://chaoxu.prof/posts/2020-07-11-yotta-savings-and-covering-designs.html</link>
    <description><![CDATA[<br />
<div>
<p><a href="https://www.withyotta.com/">Yotta Savings</a> is a FDIC
insured savings account that gives you “interest” in another way. It has
a 0.2% APR. It is much better than the APR of many banks, but much worse
than actual high APR savings accounts, e.g. Marcus, Ally. However, for
each $25, Yotta gives you a ticket weekly to their drawing, which you
would have some chance of winning a big amount of money. This is very
close to <a href="https://en.wikipedia.org/wiki/Premium_Bond">Premium
Bond</a> in the UK. What if one wants to actually figure out the actual
APR one can hope for. People at <a
href="https://news.ycombinator.com/item?id=23780062">Hacker News</a>
already did a lot of analysis, and in expectation you are looking at
more than 3% APR. If you are going to sign up, please use my referral
code <code>CHAO1</code> and we both get 100 tickets.</p>
<p>What about worst case guaranteed return? For example, if you believe
Yotta is out to get you and draw numbers to minimize what you are going
to earn (paranoid? yep). The entire expectation calculation means
nothing to you. What is the guaranteed return if you save a large sum of
money in there. Note each person can have at most 10000 tickets, so a
maximum investment of $250,000.</p>
<p>Recall <span class="math inline">[n]=\set{1,\ldots,n}</span>. Each
ticket allows you to pick a size <span class="math inline">6</span>
subset <span class="math inline">X</span> of <span
class="math inline">[70]</span>, and a single element <span
class="math inline">y</span> from <span
class="math inline">[25]</span>. At the end of the week, Yotta also
would have drawn a <span class="math inline">6</span> element subset
<span class="math inline">A</span> of <span
class="math inline">[70]</span>, and a single element <span
class="math inline">b</span> from <span class="math inline">[25]</span>.
Let a combination <span class="math inline">(X,y)</span> be called a
ticket, and <span class="math inline">T</span> is the space of all
tickets. A draw is also a ticket.</p>
<p>To actually find the optimum, you can write a huge optimization
problem. Assume we have a valuation function <span
class="math inline">f:T\times T\to \R</span>, where <span
class="math inline">f(u,v)</span> is the winning for given ticket <span
class="math inline">u</span> and draw <span
class="math inline">v</span>. For <span class="math inline">n</span>
ticket, the optimum guaranteed return is <span
class="math inline">\max_{F\in T^n} \min_{v\in T} \sum_{u\in F}
f(u,v)</span>. This problem is too large to solve exactly. Let’s try
some existing tools to get a quick lower bound.</p>
<p>There are many ways to win, but we only need to concentrate on the
following, the rest are not helpful with meeting the bottom line. Let
<span class="math inline">u=(X,y), v=(A,b)</span>.</p>
<ul>
<li>If <span class="math inline">b=y</span> and <span
class="math inline">|X\cap Y|=0</span>, then <span
class="math inline">f(u,v)=0.1</span>.</li>
<li>If <span class="math inline">b=y</span> and <span
class="math inline">|X\cap Y|=1</span>, then <span
class="math inline">f(u,v)=0.2</span>.</li>
<li>If <span class="math inline">b=y</span> and <span
class="math inline">|X\cap Y|=2</span>, then <span
class="math inline">f(u,v)=0.8</span>.</li>
<li>If <span class="math inline">b=y</span> and <span
class="math inline">|X\cap Y|=3</span>, then <span
class="math inline">f(u,v)=10</span>.</li>
<li>If <span class="math inline">b\neq y</span> and <span
class="math inline">|X\cap Y|=3</span>, then <span
class="math inline">f(u,v)=0.4</span>.</li>
</ul>
<p>It is easy to see just by looking at <span
class="math inline">y</span>, if you have 25 tickets, you can win at
least $0.1 weekly by picking each possible <span
class="math inline">y</span>. This gives you already a 0.83% APR by
simply saving $625.</p>
<p>How about <span class="math inline">X</span>? Let <span
class="math inline">a_0=.1, a_1=.2, a_2=.8</span>. If we can find a
small family of <span class="math inline">6</span> element subsets, such
that every set of size <span class="math inline">i</span> are covered,
then we can earn at least <span class="math inline">a_i</span>.</p>
<div class="theorem-environment Definition" data-index="1"
type="Definition">
<span class="theorem-header"><span class="type">Definition</span><span
class="index">1</span></span>
<p>A <span class="math inline">(v,k,t)</span><em>-covering design</em>
is family of <span class="math inline">k</span>-element subsets of <span
class="math inline">[v]</span>, such that every <span
class="math inline">t</span>-element subset of <span
class="math inline">[v]</span> is covered. The <span
class="math inline">k</span>-element subsets are called
<em>blocks</em>.</p>
</div>
<p>So we are looking for a <span class="math inline">(70,6,k)</span>
design of small size. <a href="https://www.dmgordon.org">Dan Gordon</a>
has curated a good <a href="https://www.dmgordon.org/cover/">collection
of covering designs</a>. The smallest known covering designs for each
<span class="math inline">k</span> are <span class="math inline">12,
172, 3258</span>. The last one is too large to be useful, but gives an
indication on the size we are looking at. In fact, we can ask for
stronger property.</p>
<div class="theorem-environment Definition" data-index="2"
type="Definition">
<span class="theorem-header"><span class="type">Definition</span><span
class="index">2</span></span>
<p>A <span class="math inline">n</span>-block <span
class="math inline">(v,k,t)</span>-design is called <em>nice</em>, if
for each <span class="math inline">t&#39;\leq t</span> subset, it is
covered by at least <span class="math inline">\left\lfloor n{v\choose
k}/{v\choose t&#39;} \right\rfloor</span> blocks.</p>
</div>
<p><a
href="https://ljcr.dmgordon.org/show_cover.php?v=70&amp;k=6&amp;t=2">The
<span class="math inline">(70,6,2)</span>-covering design by Jan de Heer
and Steve Muir</a> is a nice design.</p>
<p>At <span class="math inline">12\times 25=300</span> tickets, we can
guarantee a win of <span class="math inline">.2+11\times .1=1.3</span>
by creating 25 copies of the <span
class="math inline">(70,6,1)</span>-covering design. This is 0.9% APR if
you put in $7500.</p>
<p>Similarly, at <span class="math inline">172\times 25=4300</span>
tickets, one can guarantee at least a win of <span
class="math inline">.8</span> by creating 25 copies of the <span
class="math inline">(70,6,2)</span>-covering design. Due to it is also a
nice design, each element appears at least 14 times. So we are looking
at <span class="math inline">.8+13\times .2 + 158\times .1=19.2</span>,
which is a 0.93% APR for a investment of $107,500. </p>
<p>This is only a lower bound to the optimization problem, so maybe even
more APR can be obtained through better design. Together with the 0.2%
interest you earn a guaranteed 1.13% APR for having a lot of money.</p>
<p>We can do more if certain design exists. If we can find a <span
class="math inline">(70,6,3)</span>-covering design of <span
class="math inline">25 \times n</span> blocks that can be partitioned
into 25 nice <span class="math inline">(70,6,2)</span>-covering designs,
then we can do more. In theory, a nice <span
class="math inline">(70,6,2)</span>-covering design has a lower bound of
164 blocks. So taking <span class="math inline">n=164</span>, we are
looking at:</p>
<ol type="1">
<li>1 ticket of .8 winning,</li>
<li>1 ticket of .4 winning,</li>
<li>13 tickets of .2 winning,</li>
<li>150 tickets of .1 winning.</li>
</ol>
<p>So you get 0.96% APR for $102,500 in savings. My guess is there is a
potential of finding a spot of 1% APR by solving the optimization
problem exactly.</p>
<p>Input the entire design into the Yotta system every week is <em>a
crazy amount</em> of work, and clearly not worth the time. It is better
to be not paranoid and let the algorithm give you random numbers. Or
hope one day Yotta allows one to import a list of numbers.</p>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2020-07-11">2020-07-11</time>. </div>
    <div class="info">Tags: banking, probability.</div>
</div>]]></description>
    <pubDate>Sat, 11 Jul 2020 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2020-07-11-yotta-savings-and-covering-designs.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>The value of a gift card in beancount</title>
    <link>https://chaoxu.prof/posts/2020-06-05-the-value-of-a-gift-card.html</link>
    <description><![CDATA[<br />
<div>
<p>I’m using beancount to do accounting. In beancount, you are allowed
to have commodities. One can view gift card as commodity, but also as a
currency.</p>
<p>Say, I bought an $100 Amazon gift card for $90, I would write
<code>100 AMAZON {0.9 USD}</code>, which means 100 units of Amazon with
unit cost $0.9. Later on, I used $50 Amazon gift card, then I can write
<code>50 AMAZON {0.9 USD} @ 1 USD</code>. Here <code>@ 1 USD</code>
means the price is $1, and <code>{0.9 USD}</code> tells the program to
look for 50 unit of Amazon with unit cost $0.9.</p>
<p>Of course, often one do not care which amazon gift card was used. So
beancount allows one to write <code>50 AMAZON {} @ 1 USD</code>, and
beancount automatically finds 50 units of amazon gift card through some
predefined rules (For example, first in first out). I sold the remaining
$50 Amazon gift card for $47.5. So I would write
<code>50 AMAZON {} @ 0.95 USD</code>.</p>
<p>During the event where the gift card is used, we can record the
profit by subtract cost from price. So just like stocks, we can obtain
realized profit and loses. This is great and all, except a simple
operations is impossible in beancount. It is impossible to move these
amazon gift card to another account without losing all the cost
information. This actually happens in real life. I might buy amazon gift
card, but load gift card to different accounts. In beancount, I have no
way of relaying this info.</p>
<p>Here is a hack. Having a proxy price.</p>
<p>The idea is amazon gift card should always have a value of $x.
Whenever you buy amazon gift card for $y per unit, you record a
profit/loss of $x - $y. Whenever you use your amazon gift card at value
$z per unit, you record a profit/loss of $z-$x.</p>
<p>Here you can set <span class="math inline">x</span> to be anything.
But for simplifying calculation, 1 is sufficient. Setting it to <span
class="math inline">1</span> is the best option since it simplifies the
computation.</p>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2020-06-05">2020-06-05</time>. </div>
    <div class="info">Tags: accounting.</div>
</div>]]></description>
    <pubDate>Fri, 05 Jun 2020 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2020-06-05-the-value-of-a-gift-card.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Maximize Cash Back</title>
    <link>https://chaoxu.prof/posts/2020-04-10-maximize-cash-back.html</link>
    <description><![CDATA[<br />
<div>
<p>Credit cards often offers rewards for purchases. For example, a card
that gives 5% cash back for grocery stores. Also, credit cards often can
be used to buy gift cards for specific stores.</p>
<p>For example, one can use Chase Ink Cash (CIC) and go to Staples and
buy gift card for Amazon for effectively 7.5% off Amazon (I value UR at
1.5 cents each).</p>
<p>However, there is usually a limit. CIC caps the reward spending to
$25000. Still, it would translate to $1875 of savings. Anything
afterwards only earns 1.5%.</p>
<p>I often do large purchases at some retailers, and I have huge number
of credit cards. It make sense for me to optimize spending. I use
historical data to estimate amount of spending at retailers, and come up
with a nice optimization problem.</p>
<p>There are <span class="math inline">k</span> stores, we want to
purchase an item of value <span class="math inline">d_i</span> in store
<span class="math inline">i</span>, and want spend the least amount of
money.</p>
<p>Stores can also sell gift cards for specific stores (some gives cash
back), and one can use the gift card to buy item from other stores. For
simplicity, we assume gift card for a particular store can be used to
buy gift cards (so it work just like cash). <span
class="math inline">g_{i,j}</span> is the cash back one obtain for
buying <span class="math inline">1</span> unit of gift card for store
<span class="math inline">j</span> from store <span
class="math inline">i</span>.</p>
<p>We also have <span class="math inline">n</span> credit cards. Each
credit card have an upper limit <span class="math inline">u_i</span>.
For credit card <span class="math inline">i</span>, it gives cash back
of <span class="math inline">c_{i,j}</span> per unit on store <span
class="math inline">j</span> if total spend of the credit card is no
larger than <span class="math inline">u_i</span>, otherwise it give cash
back <span class="math inline">c&#39;_{i,j}</span>.</p>
<p>This is a min-cost flow problem. Indeed, let’s build the graph. Edges
default to have infinite capacity and 0 cost. Node default to have 0
demand.</p>
<p>For credit card <span class="math inline">i</span>, we create <span
class="math inline">3</span> nodes, <span class="math inline">a_i,
b_i^+, b_i^-</span>. There is is edge <span
class="math inline">(a_i,b_i^+)</span> with capacity <span
class="math inline">u_i</span>, there is an edge <span
class="math inline">(a_i,b_i^-)</span> with infinite capacity. For each
store, we create a node <span class="math inline">s_i</span>, and there
are edges <span class="math inline">(s_i,s_j)</span> with cost <span
class="math inline">-g_{i,j}</span>. The demand on <span
class="math inline">s_i</span> is <span class="math inline">d_i</span>.
For each credit card <span class="math inline">i</span> and store <span
class="math inline">j</span>, there is an edge <span
class="math inline">(b_i^+,s_i)</span> with cost <span
class="math inline">-c_{i,j}</span>, and an edge <span
class="math inline">(b_i^-,s_i)</span> with cost <span
class="math inline">-c&#39;_{i,j}</span>. Finally add a source node
connect to each <span class="math inline">a_i</span>. Source node has
demand <span class="math inline">-\sum_{i} d_i</span>.</p>
<p>Some stores does not allow gift card to be used to purchase more gift
cards. Indeed, this was not the case a long time ago, until people
abused the price difference to generate infinite money.</p>
<p>This can be fixed by duplicate this store into a cash version, so
<span class="math inline">s_{c,i}</span> and gift card version <span
class="math inline">s_{g,i}</span>. We redirect edges to the correct
ones. Namely credit card goes to <span
class="math inline">s_{c,i}</span> and edges from stores goes to <span
class="math inline">s_{g,i}</span>. Also, create edges <span
class="math inline">(s_{c,i},s_i)</span> and <span
class="math inline">(s_{g,i},s_i)</span>.</p>
<p>We are only thinking about cash backs, but there could also be
discounts. It is fairly rare to see discounts, especially for companies
that sell other gift cards. The difference between cash back and
discount is when you obtain your money back. Cash back you get your
money back after the transaction. For discounts, you pay less.</p>
<p>Adding discounts <em>fundamentally</em> changes the problem. In the
min-cost flow formulation, the cost keeps track of cash backs, and
demand is keep track of how much money is spent. This does not work when
there are discounts.</p>
<p>Instead, we have to venture into generalized flow. There is an extra
factor of <span class="math inline">\gamma</span> on each edge, such
that the flow going in is <span class="math inline">1</span>, then the
flow going out is <span class="math inline">\gamma</span>.</p>
<p>Anyway, one thing I learned is using credit cards to buy gift cards
from grocery store (Amex Gold) or staples (using Chase Ink Cash) are
amazing. Netting you large discounts on many vendors you usually cannot
get a huge discount for.</p>
<p>Some more interesting things to add. Buying gift cards from grocery
stores can obtain fuel points. Fuel points translate to discounts on
gas. However, there is only so much gas one can use (unless you selling
it to others). So one can view grocery stores as having a higher
discount up to a certain limit. This can also be modeled in the
graph.</p>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2020-04-10">2020-04-10</time>. </div>
    <div class="info">Tags: math, life.</div>
</div>]]></description>
    <pubDate>Fri, 10 Apr 2020 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2020-04-10-maximize-cash-back.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Bounds on number of cuts</title>
    <link>https://chaoxu.prof/posts/2019-11-27-bounds-on-cuts.html</link>
    <description><![CDATA[<br />
<div>
<p>Consider we have an undirected graph <span
class="math inline">G=(V,E)</span> of <span class="math inline">n</span>
vertices, and there are <em>positive</em> cost <span
class="math inline">c:E\to \R^+</span> on the edges. We define <span
class="math inline">c(F)=\sum_{e\in F}c(e)</span>, to be the cost
(value) of <span class="math inline">F\subset E</span>.</p>
<p>Let <span class="math inline">\mathcal{P}</span> be a partition of
<span class="math inline">V</span> where each partition class is
non-empty. We define <span class="math inline">E(\mathcal{P})</span> to
be the set of edges with end points in two different partition classes.
A set of edges <span class="math inline">F</span> is called a <em><span
class="math inline">k</span>-cut</em>, if <span
class="math inline">F=E(\mathcal{P})</span> for some <span
class="math inline">\mathcal{P}</span> such that <span
class="math inline">|\mathcal{P}|\geq k</span>.</p>
<p>We stress that by this definition, a <span
class="math inline">k</span>-cut is always a <span
class="math inline">j</span>-cut for <span class="math inline">j\leq
k</span>. A <em>cut</em> is defined as a <span
class="math inline">2</span>-cut. A min-<span
class="math inline">k</span>-cut is a <span
class="math inline">k</span>-cut of minimum value (cost). We let <span
class="math inline">\lambda_k</span> to denote the value of the
min-<span class="math inline">k</span>-cut. A <span
class="math inline">\alpha</span>-approximate <span
class="math inline">k</span>-cut is a cut of value at most <span
class="math inline">\alpha\lambda_k</span>.</p>
<p>It is well known that the number of min-cuts in a graph is <span
class="math inline">{n\choose 2}</span>. <span class="citation"
data-cites="KargerS96">[<a href="#ref-KargerS96"
role="doc-biblioref">1</a>]</span></p>
<p>Unless specifically stated, we assume <span
class="math inline">k</span> is a fixed integer at least <span
class="math inline">2</span>, and <span
class="math inline">\alpha</span> is a fixed value at least <span
class="math inline">1</span>.</p>
<p>We can express the state alternatively.</p>
<div class="theorem-environment Theorem" data-index="1" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">1</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c(F)\leq \lambda_2</span> is <span
class="math inline">O(n^2)</span>.</p>
</div>
<h1 data-number="1" id="bounds-related-to-approximate-min-cuts"><span
class="header-section-number">1</span> Bounds related to approximate
min-cuts</h1>
<p>What happens when we want to know about the number of cuts with value
at most <span class="math inline">\alpha \lambda_2</span>?</p>
<p>By simply analyzing Karger’s algorithm, one can obtain the
following.</p>
<div class="theorem-environment Theorem" data-index="2" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">2</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c(F)\leq \alpha \lambda_2</span> is <span
class="math inline">O(n^{2\alpha})</span>.</p>
</div>
<p>With more careful analysis using tree packing, Karger added a floor
function to the exponent <span class="citation"
data-cites="Karger00">[<a href="#ref-Karger00"
role="doc-biblioref">2</a>]</span>.</p>
<div class="theorem-environment Theorem" data-index="3" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">3</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c(F)\leq \alpha \lambda_2</span> is <span
class="math inline">O(n^{\floor{2\alpha}})</span>.</p>
</div>
<p>Indeed, we do have a lower bound of <span class="math inline">{n
\choose \floor{2\alpha}}</span>. Just consider an unweighted cycle,
where min-cut has value <span class="math inline">2</span>. We can pick
any <span class="math inline">\floor{2\alpha}</span> edges, which forms
a cut of value at most <span class="math inline">\alpha</span> times the
min-cut.</p>
<p>Note that we require <span class="math inline">\alpha</span> to a
fixed value. This is because there is a dependency on <span
class="math inline">\alpha</span> hidden inside the big <span
class="math inline">O</span>. Our lower bound is absolute and does not
depending on <span class="math inline">\alpha</span> being fixed. It
would be interesting to obtain a matching upper bound for arbitrary
<span class="math inline">\alpha</span>. Hence we can consider the
problem with <strong>strict inequality</strong>.</p>
<div id="approxcutconjecture" class="theorem-environment Conjecture"
data-index="4" type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span
class="index">4</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c(F)&lt; \alpha \lambda_2</span> is <span
class="math inline">O(n^{\ceil{2\alpha}-1})</span>.</p>
</div>
<p>Henzinger and Williamson showed the conjecture true for all <span
class="math inline">\alpha\leq \frac{3}{2}</span> <span class="citation"
data-cites="HenzingerW96">[<a href="#ref-HenzingerW96"
role="doc-biblioref">3</a>]</span>.</p>
<h1 data-number="2"
id="bounds-related-to-alpha-approximate-min-k-cut"><span
class="header-section-number">2</span> Bounds related to <span
class="math inline">\alpha</span>-approximate min-<span
class="math inline">k</span>-cut</h1>
<p>There are multiple ways to obtain the following theorem. For example,
directly generalize Karger’s argument for cut counting.</p>
<div class="theorem-environment Theorem" data-index="5" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">5</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c(F)\leq \lambda_k</span> is <span
class="math inline">O(n^{2(k-1)})</span>.</p>
</div>
<p>One can show a lower bounds of the form <span
class="math inline">{n\choose k}</span>. Again, a cycle would be an
example of such lower bound. The min-<span
class="math inline">k</span>-cut has value <span
class="math inline">k</span>, and can be obtained by picking any <span
class="math inline">k</span> edges. Recently, the upper bound has been
closed (up to constant factor if <span class="math inline">k</span> is
fixed) <span class="citation" data-cites="GuptaHLL21">[<a
href="#ref-GuptaHLL21" role="doc-biblioref">4</a>]</span>.</p>
<div class="theorem-environment Theorem" data-index="6" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">6</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c(F)\leq \lambda_k</span> is <span
class="math inline">n^k k^{O(k^2)}</span>. Namely <span
class="math inline">O(n^k)</span> for fixed <span
class="math inline">k</span>.</p>
</div>
<p>In fact, they proved it by prorving the stronger theorem on <span
class="math inline">\alpha</span>-approximate min-<span
class="math inline">k</span>-cuts.</p>
<div class="theorem-environment Theorem" data-index="7" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">7</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c(F)\leq \alpha \lambda_k</span> is <span
class="math inline">n^{\alpha k} k^{O(\alpha k^2)}</span>. Namely <span
class="math inline">O(n^{\alpha k})</span> for fixed <span
class="math inline">k</span>.</p>
</div>
<p>Unlike <span class="math inline">\alpha</span>-approximate min-cuts,
there is no floor function in the exponent. Hence a natural conjecture
would be.</p>
<div class="theorem-environment Conjecture" data-index="8"
type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span
class="index">8</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c(F)\leq \alpha \lambda_k</span> is $O(n^{k}).</p>
</div>
<h1 data-number="3" id="bounds-on-approximate-parametric-cuts"><span
class="header-section-number">3</span> Bounds on (approximate)
parametric cuts</h1>
<p>Consider we have <span class="math inline">d</span> weight functions
<span class="math inline">c_1,\ldots,c_d:E\to \R_{\geq 0}</span>. Define
<span class="math inline">c^\mu(e) = \sum_{i=1}^d \mu_i c_i(e)</span>
for <span class="math inline">\mu\in \R_{\geq 0}^d</span>. We are
interested in knowing about cuts <span class="math inline">F</span> such
that <span class="math inline">c^\mu(F)</span> is bounded by <span
class="math inline">\alpha \lambda_{\mu,k}</span>, where <span
class="math inline">\lambda_{\mu,k}</span> is the min-<span
class="math inline">k</span>-cut value when the cost function is <span
class="math inline">c^\mu</span>.</p>
<p>Karger showed the following <span class="citation"
data-cites="Karger16">[<a href="#ref-Karger16"
role="doc-biblioref">5</a>]</span>.</p>
<div class="theorem-environment Theorem" data-index="9" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">9</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c_\mu(F)\leq \lambda_{\mu,2}</span> for some <span
class="math inline">\mu\in \R_{\geq 0}^d</span> is <span
class="math inline">O(n^{d+1})</span>.</p>
</div>
<p>A even more general theorem follows, allowing <span
class="math inline">\alpha</span>-approximate <span
class="math inline">k</span>-cuts.</p>
<div class="theorem-environment Theorem" data-index="10" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">10</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c_\mu(F)\leq \alpha \lambda_{\mu,k}</span> for some
<span class="math inline">\mu\in \R_{\geq 0}^d</span> is <span
class="math inline">O(n^{2\alpha(k-1)+d-1})</span>.</p>
</div>
<p>Of course, knowing the current result for number of <span
class="math inline">\alpha</span>-approximate <span
class="math inline">k</span>-cuts, we would conjecture the following for
parametric cuts.</p>
<div class="theorem-environment Conjecture" data-index="11"
type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span
class="index">11</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c_\mu(F) \leq \alpha \lambda_{\mu,k}</span> for
<span class="math inline">\mu\in \R_{\geq 0}^d</span> is <span
class="math inline">O(n^{\alpha k+d-1})</span>.</p>
</div>
<p>Note, we might relax the requirement that all <span
class="math inline">c_i</span> and <span class="math inline">\mu</span>
are non-negative. Aissi et. al. showed the following <span
class="citation" data-cites="AissiMMQ15">[<a href="#ref-AissiMMQ15"
role="doc-biblioref">6</a>]</span>, only assuming <span
class="math inline">c_\mu \geq 0</span>.</p>
<div class="theorem-environment Theorem" data-index="12" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">12</span></span>
<p>The number of cuts <span class="math inline">F</span> such that <span
class="math inline">c_\mu(F)\leq \lambda_{\mu}</span> for some <span
class="math inline">c_\mu\geq 0</span> is <span
class="math inline">O(m^d n^2\log^{d-1} n)</span>.</p>
</div>
<p>Can we obtain a stronger bound for <span class="math inline">c_\mu
\geq 0</span>?</p>
<p>Parametric min-cut is related to multicriteria min-cut, which also
have a lot of open problems <span class="citation"
data-cites="BeidemanCX23">[<a href="#ref-BeidemanCX23"
role="doc-biblioref">7</a>]</span>.</p>
<h1 data-number="4" id="projected-cut-bounds"><span
class="header-section-number">4</span> Projected cut bounds?</h1>
<p>Let <span class="math inline">\tau_e = \min_{U:e\in
\delta(U)}c(\delta(U))</span>, i.e. the minimum value of a cut
containing <span class="math inline">e</span>. Fung et. al. showed a
projected generalization of the cut counting bound <span
class="citation" data-cites="FungHHP19">[<a href="#ref-FungHHP19"
role="doc-biblioref">8</a>]</span> by ignore edges appeared in small
cuts. Let <span class="math inline">E_\lambda = \set{ e | \tau_e \geq
\lambda }</span>.</p>
<div class="theorem-environment Theorem" data-index="13" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span
class="index">13</span></span>
<p>The number of sets of the form <span class="math inline">F\cap
E_\lambda</span> where <span class="math inline">F</span> is a cut such
that <span class="math inline">c(F)\leq \alpha \lambda</span> is <span
class="math inline">O(n^{2\alpha})</span>.</p>
</div>
<p>If we let <span class="math inline">\lambda</span> be the min-cut
value, this is precisely the <span
class="math inline">\alpha</span>-approximate cut counting bound.</p>
<p>We can ask if all our theorem can have a projected cut version. We
don’t know if it extends to <span class="math inline">k</span>-cuts (or
what is the correct generalization).</p>
<h1 data-number="5" id="what-about-hypergraphs"><span
class="header-section-number">5</span> What about hypergraphs?</h1>
<p>Most of the above results in graphs generalizes to rank <span
class="math inline">r</span> hypergraphs with an extra factor related to
<span class="math inline">r</span>, often is <span
class="math inline">2^r</span>. See the table in <span class="citation"
data-cites="BeidemanCX23">[<a href="#ref-BeidemanCX23"
role="doc-biblioref">7</a>]</span> for a survey. However, almost all
<em>exact</em> min-cut counting problem are unknown for hypergraphs with
unbounded rank.</p>
<div class="theorem-environment Conjecture" data-index="14"
type="Conjecture">
<span class="theorem-header"><span class="type">Conjecture</span><span
class="index">14</span></span>
<p>All the exact min-cut counting can be generalized to hypergraphs with
unbounded rank.</p>
</div>
<p>One can construct a hypergraph where every set <span
class="math inline">\emptyset \subsetneq S\subsetneq V</span> induces a
distinct <span class="math inline">\alpha</span>-approximate min-cut for
all <span class="math inline">\alpha&gt;1</span>, so counting <span
class="math inline">\alpha</span>-approximate min-cut is unintresting
for hypergraphs of unbounded rank.</p>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-KargerS96" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">D.
Karger, C. Stein, <strong>A new approach to the minimum cut
problem</strong>, Journal of ACM. 43 (1996) 601–640.</div>
</div>
<div id="ref-Karger00" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div
class="csl-right-inline">D.R. Karger, <strong>Minimum cuts in
near-linear time</strong>, J. ACM. 47 (2000) 46–76 <a
href="https://doi.org/10.1145/331605.331608">10.1145/331605.331608</a>.</div>
</div>
<div id="ref-HenzingerW96" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">M.
Henzinger, D.P. Williamson, <strong>On the number of small cuts in a
graph</strong>, Information Processing Letters. 59 (1996) 41–44 <a
href="https://doi.org/10.1016/0020-0190(96)00079-8">https://doi.org/10.1016/0020-0190(96)00079-8</a>.</div>
</div>
<div id="ref-GuptaHLL21" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">A.
Gupta, D.G. Harris, E. Lee, J. Li, <strong>Optimal bounds for the k-cut
problem</strong>, J. ACM. 69 (2021) <a
href="https://doi.org/10.1145/3478018">10.1145/3478018</a>.</div>
</div>
<div id="ref-Karger16" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[5] </div><div
class="csl-right-inline">D.R. Karger, Enumerating parametric global
minimum cuts by random interleaving, in: Proceedings of the Forty-Eighth
Annual ACM Symposium on Theory of Computing, ACM, New York, NY, USA,
2016: pp. 542–555 <a
href="https://doi.org/10.1145/2897518.2897578">10.1145/2897518.2897578</a>.</div>
</div>
<div id="ref-AissiMMQ15" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">H.
Aissi, A.R. Mahjoub, S.T. McCormick, M. Queyranne, <strong>Strongly
polynomial bounds for multiobjective and parametric global minimum cuts
in graphs and hypergraphs</strong>, Mathematical Programming. 154 (2015)
3–28 <a
href="https://doi.org/10.1007/s10107-015-0944-8">10.1007/s10107-015-0944-8</a>.</div>
</div>
<div id="ref-BeidemanCX23" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">C.
Beideman, K. Chandrasekaran, C. Xu, <strong>Multicriteria cuts and
size-constrained k-cuts in hypergraphs</strong>, Mathematical
Programming. 197 (2023) 27–69 <a
href="https://doi.org/10.1007/s10107-021-01732-0">10.1007/s10107-021-01732-0</a>.</div>
</div>
<div id="ref-FungHHP19" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[8] </div><div
class="csl-right-inline">W.-Shing. Fung, Ramesh. Hariharan, N.J.A.
Harvey, Debmalya. Panigrahi, <strong>A general framework for graph
sparsification</strong>, SIAM Journal on Computing. 48 (2019) 1196–1223
<a
href="https://doi.org/10.1137/16M1091666">10.1137/16M1091666</a>.</div>
</div>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2019-11-27">2019-11-27</time>. </div>
    <div class="info">Tags: Graph Theory.</div>
</div>]]></description>
    <pubDate>Wed, 27 Nov 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2019-11-27-bounds-on-cuts.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Word break with cost</title>
    <link>https://chaoxu.prof/posts/2019-09-19-word-break-with-cost.html</link>
    <description><![CDATA[<br />
<div>
<div class="theorem-environment Problem" data-index="1" type="Problem">
<span class="theorem-header"><span class="type">Problem</span><span
class="index">1</span></span>
<p>Given a set of strings <span class="math inline">W</span>, a cost
function <span class="math inline">c:W\to \R</span> and a string <span
class="math inline">s</span>. Find elements <span
class="math inline">w_1,\ldots,w_k\in W</span> such that <span
class="math inline">s=w_1\ldots w_k</span>, and <span
class="math inline">\sum_{i=1}^k c(w_i)</span> is minimized.</p>
</div>
<p>This problem is a generalization of the <a
href="https://leetcode.com/problems/word-break/">word break</a> problem
on leetcode. Many algorithms you see online assumes that each string in
<span class="math inline">W</span> has constant length, checking the
hash table takes <span class="math inline">O(1)</span> time, and obtains
an <span class="math inline">O(n^2)</span> time algorithm. It is not as
easy if the strings can have arbitrary length. Here we show an algorithm
that considers the strings in <span class="math inline">W</span> have
arbitrary length.</p>
<p>Assume the input <span class="math inline">s</span> has length <span
class="math inline">n</span>. Consider the following graph <span
class="math inline">G=(V,E)</span>, where <span
class="math inline">V=\set{0,\ldots,n}</span>, and there is an edge from
<span class="math inline">i</span> and <span
class="math inline">j</span>, if <span
class="math inline">s[i+1..j]=w\in W</span>, the label of the edge <span
class="math inline">(i,j)</span> is the string <span
class="math inline">w</span>, and the cost is <span
class="math inline">c(w)</span>. Let <span class="math inline">L</span>
be total length of the input, namely $_{wW} |w| + |s|. Let <span
class="math inline">z</span> be number of substrings in <span
class="math inline">s</span> matches some element in <span
class="math inline">W</span>. The graph has <span
class="math inline">z</span> edges. Note <span
class="math inline">z=O(n\sqrt{L})</span>. Indeed, the sum of the length
of the labels of all outgoing edges cannot be more than <span
class="math inline">L</span>, and the length of each label is different.
Hence each vertex can have at most <span
class="math inline">O(\sqrt{L})</span> outgoing edges. The graph is a
DAG, so we can find the shortest path from <span
class="math inline">0</span> to <span class="math inline">n</span> in
linear time with respect to the number of edges. This shows if we can
compute the graph in <span class="math inline">O(z+L)</span> time, then
we solve the problem in <span class="math inline">O(z+L)</span>
time.</p>
<p>We can build an Aho–Corasick automaton for <span
class="math inline">W</span> in <span class="math inline">O(L)</span>
time. It can be used to find all substrings of <span
class="math inline">s</span> that matches something in <span
class="math inline">W</span> by traversing the automaton once. The
running time is the total number of substrings matched, which is <span
class="math inline">O(z)</span>. Hence building the graph takes <span
class="math inline">O(z+L)</span> time. <span
class="math inline">z</span> is clearly no more than <span
class="math inline">nm</span>, where <span
class="math inline">m=|W|</span>. Also, it is also clear <span
class="math inline">z=O(n\sqrt{L})</span>. Indeed, there can be at most
<span class="math inline">O(\sqrt{L})</span> edges start from <span
class="math inline">i</span>, since each edge has a label of different
length, and sum of those length labels is no larger than <span
class="math inline">L</span>.</p>
<p>If we only want to know if there exists a solution, then there is a
<span class="math inline">\tilde{O}(nL^{1/3}+L)</span> time algorithm
<span class="citation" data-cites="BringmannGL17">[<a
href="#ref-BringmannGL17" role="doc-biblioref">1</a>]</span>. The
algorithm is close to optimal assuming the algorithm is combinatorial
and the alphabet can be arbitrarily large. A recent progress showed the
version with minimum cost is also solvable in <span
class="math inline">\tilde{O}(nL^{1/3}+L)</span> time <span
class="citation" data-cites="ChanH20">[<a href="#ref-ChanH20"
role="doc-biblioref">2</a>]</span>.</p>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-BringmannGL17" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">K.
Bringmann, A. Grønlund, K.G. Larsen, A dichotomy for regular expression
membership testing, in: 2017 IEEE 58th Annual Symposium on Foundations
of Computer Science (FOCS), 2017: pp. 307–318 <a
href="https://doi.org/10.1109/FOCS.2017.36">10.1109/FOCS.2017.36</a>.</div>
</div>
<div id="ref-ChanH20" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div
class="csl-right-inline">T.M. Chan, Q. He, <span class="nocase">More on
Change-Making and Related Problems</span>, in: F. Grandoni, G. Herman,
P. Sanders (Eds.), 28th Annual European Symposium on Algorithms (ESA
2020), Schloss Dagstuhl–Leibniz-Zentrum f<span>ü</span>r Informatik,
Dagstuhl, Germany, 2020: pp. 29:1–29:14 <a
href="https://doi.org/10.4230/LIPIcs.ESA.2020.29">10.4230/LIPIcs.ESA.2020.29</a>.</div>
</div>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2019-09-19">2019-09-19</time>. </div>
    <div class="info">Tags: Algorithm.</div>
</div>]]></description>
    <pubDate>Thu, 19 Sep 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2019-09-19-word-break-with-cost.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Traditional vs Roth IRA under fixed amount of investment</title>
    <link>https://chaoxu.prof/posts/2019-09-06-traditional-ira-vs-roth-ira.html</link>
    <description><![CDATA[<br />
<div>
<p>I’ve read a lot of articles on Traditional vs Roth IRA. One can do a
serious mathematical analysis of which one is better, given that you
want to invest a total of <span class="math inline">x</span> income into
the account for a particular year. Money in excess of <span
class="math inline">x</span> will be put in a normal investment
account.</p>
<p>There is a widely held belief that if your effective tax rate is
higher today than when you cash out, it is always better to do pre-tax
contribution (Traditional IRA). However, we can show this is not always
the case. You need effective tax rate to be somewhat lower unless you
are in the lowest of tax bracket. Assume for simplicity, you don’t have
to pay state income tax.</p>
<p>Assumption you way more than enough money to maximize the
contribution.</p>
<p>Here are the 3 options.</p>
<ul>
<li>Type 1: (Traditional IRA, 401(k)) No tax when contributing, taxed as
ordinary income afterwards.</li>
<li>Type 2: (Roth IRA, Roth 401(k)) Taxed when contributing, and no
taxes with withdrawal.</li>
<li>Type 3: Normal account, taxed when contributing, and tax with either
ordinary income or capital gain taxes depending on type.</li>
</ul>
<p>Consider the simplest model. You have a stock that you buy and hold.
It generates no dividends. At the time when you sell it, it worths <span
class="math inline">k</span> times more. All your money will be going
into that stock.</p>
<p>Assume you allocate <span class="math inline">x</span> income into
<span class="math inline">x_1,x_2,x_3</span>, which is the amount of
income allocated into Type <span class="math inline">1,2,3</span>
accounts, respectively.</p>
<p>How much after tax income is generated when you sell the stock?</p>
<p>Let <span class="math inline">\alpha</span> be the (approximate)
effective tax rate today, <span class="math inline">\alpha&#39;</span>
is an (approximate) effective tax rate when you sell. <span
class="math inline">\beta&#39;</span> is the capital gain tax rate.</p>
<p>The after-tax income contributed by each account is</p>
<ul>
<li>Type 1: <span class="math inline">kx_1(1-\alpha&#39;)</span></li>
<li>Type 2: <span class="math inline">kx_2(1-\alpha)</span></li>
<li>Type 3: <span class="math inline">(k-1)x_3(1-\alpha)(1-\beta&#39;) +
x_3(1-\alpha) = x_3(1-\alpha)((k-1)(1-\beta&#39;)+1)</span></li>
</ul>
<p>Now, we also have the following constraint. <span
class="math inline">x_1+x_2(1-\alpha)=B</span>, where <span
class="math inline">B</span> is the maximum contribution into type 1 and
type 2 accounts. This happens because they share the same bound (this is
true for both 401(k) and IRA). Note that <span
class="math inline">x_1+x_2+x_3=x</span>. Since <span
class="math inline">B</span> and <span class="math inline">x</span> are
fixed, we have <span class="math inline">x_2 =
\frac{B-x_1}{1-\alpha}</span>, and <span class="math inline">x_3 =
x-x_1-\frac{B-x_1}{1-\alpha}</span></p>
<p>Define <span class="math inline">f(x_1)=kx_1(1-\alpha&#39;) +
k(B-x_1) +
(x-x_1-\frac{B-x_1}{1-\alpha})(1-\alpha)((k-1)(1-\beta&#39;)+1)</span>,
which is a linear function. We take the derivative of <span
class="math inline">f</span> and obtain the slope if <span
class="math inline">k(\alpha-\alpha&#39;)- (k-1)\alpha\beta&#39;</span>.
If the slope is positive, it means when should maximize type <span
class="math inline">1</span> account, and if the slope is negative, we
should maximize type <span class="math inline">2</span> account.</p>
<p>In order for the inequality to work for all <span
class="math inline">k&gt;1</span>, we need <span
class="math inline">\alpha-\alpha&#39;\geq \alpha\beta&#39;</span>. In
other words, we need <span class="math inline">\alpha&#39;\leq
\alpha(1-\beta&#39;)</span> in order to safely say it is better to
maximize type 1.</p>
<p>We didn’t even consider what happens if there are dividend involved.
It would shift the scale even more toward type 2.</p>
<p>I think the moral of the story is you have to be careful and actually
model everything correctly. Also, since there is no way to know the tax
rate in the future, some people hedge the risk by putting money in both
type 1 and type 2 accounts.</p>
<p>It looks like this still suggest putting money in Traditional IRA is
better than Roth IRA if your current tax rate is <em>much higher</em>
than your future tax rate.</p>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2019-09-06">2019-09-06</time>. </div>
    <div class="info">Tags: Tax.</div>
</div>]]></description>
    <pubDate>Fri, 06 Sep 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2019-09-06-traditional-ira-vs-roth-ira.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Impossibility theorem of marriage tax</title>
    <link>https://chaoxu.prof/posts/2019-08-28-impossibility-theorm-marriage-tax.html</link>
    <description><![CDATA[<br />
<div>
<p>It is well known that there could be <a
href="https://en.wikipedia.org/wiki/Marriage_penalty">marriage penalty
or marriage bonus</a>. For example, in 2019, if two people each make
more than $306,175, then they have to pay more tax after getting
married. In the worst case, they have to pay $8,165 more. Not that bad.
However, if one person make all the money, and the other has no income,
then together they will always pay a smaller amount of tax.</p>
<p>I always thought this is because the tax code is designed to advocate
sole breadwinner in a family, and the other person is stay at home
husband/wife. Recently, I realized it is just mathematically impossible
to have anything other than a linear tax and preserve some other nice
properties.</p>
<p>Indeed, this was shown by Lovell <span class="citation"
data-cites="Lovell82">[<a href="#ref-Lovell82"
role="doc-biblioref">1</a>]</span>.</p>
<p>Let <span class="math inline">\R_+</span> be the positive reals.
Consider functions <span class="math inline">S:\R_+ \to \R_+</span> and
<span class="math inline">J:\R_+ \to\R_+</span>. The first is for tax
paid for a single person and tax paid for a married couple file jointly.
The input for married file jointly is a single number, which is the
combination of the taxable income of the couple. This is called
horizontal equity in marriage.</p>
<p>Marriage neutral is precisely when <span
class="math inline">S(x)+S(y) = J(x+y)</span>. We define a few notions,
it is not completely the same as the ones in Lovell’s paper <span
class="citation" data-cites="Lovell82">[<a href="#ref-Lovell82"
role="doc-biblioref">1</a>]</span>, but it essentially demonstrate the
same idea.</p>
<p>A tax function <span class="math inline">T</span> should have the
following properties.</p>
<ol type="1">
<li>Reasonable Tax: <span class="math inline">0\leq T(x)\leq x</span>.
Indeed, one should not tax people more than their income. The taxation
system does not want to give free money to low income people
either.</li>
<li>Principal of Progressiveness: there is some <span
class="math inline">c&gt;0</span> such that <span
class="math inline">\frac{T(x)}{x} &gt; \frac{T(y)}{y}</span> for all
<span class="math inline">x&gt;y&gt;c</span>. Basically, the rich should
pay a larger proportion of their money to taxes.</li>
</ol>
<p>For a marriage neutral system, the reasonable tax requirement would
prove that <span class="math inline">S(x) = ax</span> for <span
class="math inline">a\in[0,1]</span>. It is easy to see we cannot hope
to have principal of progressiveness.</p>
<div class="theorem-environment Remark" type="Remark">
<span class="theorem-header"><span class="type">Remark</span></span>
<p>Married filing separately is always no better than them being single
and file their own taxes.</p>
</div>
<p>I personally think there should not be a marriage penalty at any
income level to encourage marriage. Of course, people might disagree and
think the rich should have a marriage penalty, since it is a small
amount compare to their total income so they won’t care anyways.</p>
<p>Anyway, consider the world where there can only be marriage bonus.
That is we have the property <span class="math inline">S(x)+S(y)\geq
J(x+y)</span>. An <em>easy tax function</em> is a function that has
reasonable tax property, and is a piecewise-linear convex that has at
least <span class="math inline">1</span> breakpoint larger than <span
class="math inline">0</span>. This is strictly stronger than principal
of progressiveness. This is satisfied by the current personal income tax
function used by the IRS.</p>
<p>Let <span class="math inline">S</span> be a easy tax function, then
we can obtain an easy tax function <span class="math inline">J</span>
that always gives a marriage bonus. Indeed, let <span
class="math inline">J = \inf_{a+b=x,a,b\geq 0} S(a)+S(b)</span>. <span
class="math inline">J</span> is extreme in a way that any function
greater than it at any point will cause marriage penalty. <span
class="math inline">J</span> is the infimal convolution of <span
class="math inline">S</span> and itself, which would also be
piecewise-linear convex. If <span class="math inline">S</span> is the
personal income tax function for 2019, then <span
class="math inline">J</span> matches the 2019 IRS married file jointly
function up to $612,350! For some reason I do not know, the IRS decide
to cut this <span class="math inline">J</span> off at $612,350, and then
impose a higher rate just to penalize families with two very high income
earners.</p>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-Lovell82" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div
class="csl-right-inline">M.C. LOVELL, <strong><a
href="http://www.jstor.org/stable/41862465">ON TAXING
MARRIAGES</a></strong>, National Tax Journal. 35 (1982) 507–510.</div>
</div>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2019-08-28">2019-08-28</time>. </div>
    <div class="info">Tags: Tax.</div>
</div>]]></description>
    <pubDate>Wed, 28 Aug 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2019-08-28-impossibility-theorm-marriage-tax.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>
<item>
    <title>Long distance couple back-to-back ticketing</title>
    <link>https://chaoxu.prof/posts/2019-06-18-long-distance-couple-back-to-back-ticketing.html</link>
    <description><![CDATA[<br />
<div>
<p>The reason I explored <a
href="https://chaoxu.prof/posts/2019-06-15-covert-back-to-back-ticketing.html">an
algorithm for covert back-to-back ticketing</a> in the previous blog
post, was because as someone currently in a long distance relationship.
It is important to save money on travel.</p>
<p>For long distance couples, two people can fly. Consider if the couple
decides be together each weekend, one can fly to the city of the other
on Friday night, and comes back on Sunday night. Again we can take
advantage of the back-to-back ticketing.</p>
<p>Let <span class="math inline">M</span> be a matching of a graph <span
class="math inline">G</span> where the edges are two colored. <span
class="math inline">M</span> is called <em>valid</em> if vertex <span
class="math inline">2i</span> and <span class="math inline">2i-1</span>
are contained in the same colored edge in <span
class="math inline">M</span>.</p>
<div class="theorem-environment Problem" data-index="1" type="Problem"
title="Couple back-to-back ticketing problem">
<span class="theorem-header"><span class="type">Problem</span><span
class="index">1</span><span class="name">Couple back-to-back ticketing
problem</span></span>
<p><strong>Input:</strong> A multigraph <span
class="math inline">G=(V,E)</span> where <span
class="math inline">V\subseteq [n]</span>, where each edge can be either
red or blue, and there is an edge cost function <span
class="math inline">c:E\to \R^+</span>.</p>
<p><strong>Output:</strong> A valid perfect matching <span
class="math inline">M</span> (allowing self-loops), such that the cost
is minimized.</p>
</div>
<p>Unfortunately, I don’t see how to solve this problem in polynomial
time. I could convert this problem to something that might be solved in
polynomial time in the future.</p>
<p>Note we can split the vertices. That is, for vertex <span
class="math inline">i</span>, we split it into <span
class="math inline">(i,R)</span> and <span
class="math inline">(i,B)</span> for its blue and red counter part. A
matching is <em>paired</em> if <span class="math inline">(2i,C)</span>
and <span class="math inline">(2i-1,C)</span> both has to be matched,
where <span class="math inline">C\in \set{R,B}</span>. The matching is
<em>split</em> if <span class="math inline">(i,R)</span> and <span
class="math inline">(i,B)</span> cannot be both in the matching.</p>
<p>If we just enforce one property – paired or split – then it is
solvable in polynomial time. Indeed, both are matching under
restrictions. We are interested in finding a matching <span
class="math inline">M</span>, such that the vertices covered by <span
class="math inline">M</span> is in some special structure. Namely <span
class="math inline">\Delta</span>-matroid. Since the paired property is
a very special <span class="math inline">\Delta</span>-matroid <span
class="citation" data-cites="KakimuraT14">[<a href="#ref-KakimuraT14"
role="doc-biblioref">1</a>]</span>, which was first solved in <span
class="citation" data-cites="HefnerK95">[<a href="#ref-HefnerK95"
role="doc-biblioref">2</a>]</span>. The second property is partition
matroid, which can be handled by <a
href="/posts/2019-04-27-maximum-weight-hierarchical-b-matching.html">hierarchical
<span class="math inline">b</span>-matching</a>. Reader can see each
individual restriction, the problem can be turned into a maximum weight
perfect matching.</p>
<p>If we enforce both property, the problem is open. Although the
structure is still very special, it is an <a
href="https://en.wikipedia.org/wiki/Delta-matroid">even <span
class="math inline">\Delta</span>-matroid</a>. <a
href="http://www.math.keio.ac.jp/~kakimura/">Naonori Kakimura</a>
communicated a more fundamental problem which can be solved by this
problem.</p>
<div class="theorem-environment Problem" data-index="2" type="Problem"
title="Matching with disjoint pair constraints">
<span class="theorem-header"><span class="type">Problem</span><span
class="index">2</span><span class="name">Matching with disjoint pair
constraints</span></span>
<p>Given a graph where the edges are partitioned into pairs. Find a
maximum matching where it uses at most one edge of each pair.</p>
</div>
<p>This problem can be used to solve special case of rainbow matching. A
graph where each edge has a color, a matching is a rainbow matching if
every edge in the matching has a different color. It is known that for
graphs where each color appears twice, finding a rainbow matching is
NP-hard <span class="citation" data-cites="LeP14">[<a href="#ref-LeP14"
role="doc-biblioref">3</a>]</span>. The couple back-to-back ticketing
problem is also NP-hard.</p>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-KakimuraT14" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">N.
Kakimura, M. Takamatsu, <strong><span class="nocase">Matching Problems
with Delta-Matroid Constraints</span></strong>, SIAM Journal on Discrete
Mathematics. 28 (2014) 942–961 <a
href="https://doi.org/10.1137/110860070">10.1137/110860070</a>.</div>
</div>
<div id="ref-HefnerK95" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">A.
Hefner, P. Kleinschmidt, <strong><span class="nocase">A constrained
matching problem</span></strong>, Annals of Operations Research. 57
(1995) 135–145 <a
href="https://doi.org/10.1007/BF02099694">10.1007/BF02099694</a>.</div>
</div>
<div id="ref-LeP14" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[3] </div><div
class="csl-right-inline">V.B. Le, F. Pfender, <strong>Complexity results
for rainbow matchings</strong>, Theoretical Computer Science. 524 (2014)
27–33 <a
href="https://doi.org/10.1016/j.tcs.2013.12.013">https://doi.org/10.1016/j.tcs.2013.12.013</a>.</div>
</div>
</div>
</div>
<div class="hide-on-print">
    <div class="info">Posted by <a href="https://chaoxu.prof">Chao Xu</a> on <time datetime="2019-06-18">2019-06-18</time>. </div>
    <div class="info">Tags: Optimization, algorithm, airline.</div>
</div>]]></description>
    <pubDate>Tue, 18 Jun 2019 00:00:00 UT</pubDate>
    <guid>https://chaoxu.prof/posts/2019-06-18-long-distance-couple-back-to-back-ticketing.html</guid>
    <dc:creator>Chao Xu</dc:creator>
</item>

    </channel>
</rss>
